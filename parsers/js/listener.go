// generated by Textmapper; DO NOT EDIT

package js

import (
	"fmt"
)

type NodeType int

type Listener func(t NodeType, offset, endoffset int)

const (
	NoType NodeType = iota
	Abstract
	AccessibilityModifier
	Accessor
	AdditiveExpr // left=Expr right=Expr
	Arguments    // TypeArguments? list=(Expr)*
	ArrayLiteral // list=(Expr)*
	ArrayPattern // list=(ElementPattern | Expr)* BindingRestElement?
	ArrayType    // TsType
	ArrowFunc    // NameIdent? TypeParameters? Parameters? TypeAnnotation? Body? ConciseBody? SyntaxProblem?
	AssertClause // (AssertEntry)*
	AssertEntry  // AssertionKey
	AssertionKey
	AssertsType    // ReferenceIdent? This? TsType?
	AssignmentExpr // left=Expr AssignmentOperator? right=Expr
	AssignmentOperator
	AsyncArrowFunc            // NameIdent? TypeParameters? Parameters? TypeAnnotation? Body? ConciseBody?
	AsyncFunc                 // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	AsyncFuncExpr             // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	AsyncGeneratorDeclaration // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	AsyncGeneratorExpression  // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	AsyncGeneratorMethod      // PropertyName TypeParameters? Parameters TypeAnnotation? Body?
	AsyncMethod               // PropertyName TypeParameters? Parameters TypeAnnotation? Body?
	Await
	AwaitExpr            // Expr
	BindingRestElement   // NameIdent
	BitwiseAND           // left=Expr right=Expr
	BitwiseOR            // left=Expr right=Expr
	BitwiseXOR           // left=Expr right=Expr
	Block                // (CaseClause)* list=(StmtListItem)*
	Body                 // list=(StmtListItem)*
	BreakStmt            // LabelIdent?
	CallExpr             // expr=Expr Arguments
	CallSignature        // TypeParameters? Parameters TypeAnnotation?
	Case                 // Cond (StmtListItem)*
	Catch                // BindingPattern? NameIdent? TypeAnnotation? Block
	Class                // (Modifier)* NameIdent? TypeParameters? Extends? TsImplementsClause? ClassBody
	ClassBody            // (ClassElement)*
	ClassExpr            // (Modifier)* NameIdent? TypeParameters? Extends? TsImplementsClause? ClassBody
	CoalesceExpr         // left=Expr right=Expr
	CommaExpr            // left=Expr right=Expr
	ComputedPropertyName // Expr
	ConciseBody          // Expr
	Cond                 // Expr
	ConditionalExpr      // cond=Expr then=Expr else=Expr
	ConstructSignature   // (Modifier)* TypeParameters? Parameters TypeAnnotation?
	ConstructorType      // Abstract? TypeParameters? Parameters TsType
	ContinueStmt         // LabelIdent?
	DebuggerStmt
	Declare
	DecoratorCall    // (ReferenceIdent)+ Arguments
	DecoratorExpr    // (ReferenceIdent)+
	Default          // (StmtListItem)*
	DefaultParameter // (Modifier)* BindingPattern? NameIdent? TsOptional? TypeAnnotation? Initializer?
	DoWhileStmt      // Stmt Expr
	ElementBinding   // BindingPattern Initializer?
	EmptyDecl
	EmptyStmt
	EqualityExpr       // left=Expr right=Expr
	ExponentiationExpr // left=Expr right=Expr
	ExportClause       // (ExportElement)*
	ExportDecl         // (Modifier)* TsTypeOnly? VarStmt? Decl? ExportClause? NameIdent? ModuleSpec? AssertClause?
	ExportDefault      // Expr? (Modifier)* Decl?
	ExportSpec         // ReferenceIdent? NameIdent
	ExprStmt           // Expr
	Extends            // Expr? TypeReference?
	Finally            // Block
	ForBinding         // BindingPattern? NameIdent?
	ForCondition       // Expr?
	ForFinalExpr       // Expr?
	ForInStmt          // var=Expr object=Expr Stmt
	ForInStmtWithVar   // LetOrConst? Var? ForBinding object=Expr Stmt
	ForOfStmt          // Await? var=Expr iterable=Expr Stmt
	ForOfStmtWithVar   // Await? LetOrConst? Var? ForBinding iterable=Expr Stmt
	ForStmt            // var=Expr? ForCondition ForFinalExpr Stmt
	ForStmtWithVar     // LetOrConst? Var? (LexicalBinding)* (VarDecl)* ForCondition ForFinalExpr Stmt
	Func               // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	FuncExpr           // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	FuncType           // TypeParameters? Parameters TsType
	Generator          // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	GeneratorExpr      // NameIdent? TypeParameters? Parameters TypeAnnotation? Body?
	GeneratorMethod    // PropertyName TypeParameters? Parameters TypeAnnotation? Body?
	Getter             // (Modifier)* PropertyName TypeAnnotation? Body?
	IdentExpr          // ReferenceIdent
	IfStmt             // Expr then=Stmt else=Stmt?
	ImportDecl         // TsTypeOnly? NameIdent? NameSpaceImport? NamedImports? ModuleSpec AssertClause?
	ImportSpec         // ReferenceIdent? NameIdent
	ImportType         // TsImportTypeStart TypeArguments?
	InExpr             // left=Expr right=Expr
	IndexAccess        // expr=Expr index=Expr
	IndexSignature     // (Modifier)* NameIdent TsType TypeAnnotation
	IndexedAccessType  // left=TsType index=TsType
	Initializer        // Expr
	InstanceOfExpr     // left=Expr right=Expr
	IntersectionType   // inner=(TsType)*
	JSXAttributeName
	JSXClosingElement // JSXElementName
	JSXElement        // JSXOpeningElement? JSXSelfClosingElement? (JSXChild)* JSXClosingElement?
	JSXElementName
	JSXExpr     // Expr?
	JSXFragment // (JSXChild)*
	JSXLiteral
	JSXNormalAttribute    // JSXAttributeName JSXAttributeValue?
	JSXOpeningElement     // JSXElementName TypeArguments? (JSXAttribute)*
	JSXSelfClosingElement // JSXElementName TypeArguments? (JSXAttribute)*
	JSXSpreadAttribute    // Expr
	JSXSpreadExpr         // Expr?
	JSXText
	KeyOfType // TsType
	LabelIdent
	LabelledStmt // LabelIdent Func? Stmt?
	LetOrConst
	LexicalBinding // BindingPattern? NameIdent? TsExclToken? TypeAnnotation? Initializer?
	LexicalDecl    // LetOrConst (LexicalBinding)+
	Literal
	LiteralPropertyName // Literal? NameIdent?
	LiteralType         // TemplateLiteralType?
	LogicalAND          // left=Expr right=Expr
	LogicalOR           // left=Expr right=Expr
	MappedType          // NameIdent inType=TsType asType=TsType? TypeAnnotation
	MemberMethod        // (Modifier)* MethodDefinition
	MemberVar           // (Modifier)* PropertyName TypeAnnotation? Initializer?
	Method              // PropertyName TypeParameters? Parameters TypeAnnotation? Body?
	MethodSignature     // (Modifier)* PropertyName TypeParameters? Parameters TypeAnnotation?
	Module              // (ModuleItem)*
	ModuleSpec
	MultiplicativeExpr // left=Expr right=Expr
	NameIdent          // ReferenceIdent?
	NameSpaceImport    // NameIdent
	NamedImports       // (NamedImport)*
	NamedTupleMember   // TsType
	NewExpr            // expr=Expr Arguments?
	NewTarget
	NoElement
	NonNullableType        // TsType
	NotExpr                // Expr
	NullableType           // TsType
	ObjectLiteral          // (PropertyDefinition)*
	ObjectMethod           // (Modifier)* MethodDefinition
	ObjectPattern          // (PropertyPattern)* BindingRestElement?
	ObjectType             // (TypeMember)*
	OptionalCallExpr       // expr=Expr Arguments
	OptionalIndexAccess    // expr=Expr index=Expr
	OptionalPropertyAccess // expr=Expr selector=ReferenceIdent
	OptionalTaggedTemplate // tag=Expr literal=TemplateLiteral
	Override
	Parameters        // (Parameter)*
	Parenthesized     // Expr
	ParenthesizedType // TsType
	PostDec           // Expr
	PostInc           // Expr
	PreDec            // Expr
	PreInc            // Expr
	PredefinedType
	Property          // (Modifier)* PropertyName value=Expr
	PropertyAccess    // expr=Expr? selector=ReferenceIdent
	PropertyBinding   // PropertyName ElementPattern
	PropertySignature // (Modifier)* PropertyName TypeAnnotation?
	Readonly
	ReadonlyType // TsType
	ReferenceIdent
	Regexp
	RelationalExpr    // left=Expr right=Expr
	RestParameter     // BindingPattern? NameIdent? TypeAnnotation?
	RestType          // TsType
	ReturnStmt        // Expr?
	Setter            // (Modifier)* PropertyName Parameter Body?
	ShiftExpr         // left=Expr right=Expr
	ShorthandProperty // NameIdent
	SingleNameBinding // NameIdent Initializer?
	SpreadElement     // Expr
	SpreadProperty    // Expr
	Static
	StaticBlock         // Body
	SuperExpr           // ReferenceIdent
	SwitchStmt          // Expr Block
	SyntaxProblem       // ReferenceIdent? Initializer?
	TaggedTemplate      // tag=Expr literal=TemplateLiteral
	TemplateLiteral     // template=(NoSubstitutionTemplate | TemplateHead | TemplateMiddle | TemplateTail)+ substitution=(Expr)*
	TemplateLiteralType // template=(NoSubstitutionTemplate | TemplateHead | TemplateMiddle | TemplateTail)+ substitution=(TsType)*
	This
	ThisExpr // This
	ThisType
	ThrowStmt            // Expr
	TryStmt              // Block Catch? Finally?
	TsAmbientBinding     // NameIdent TypeAnnotation? Initializer?
	TsAmbientClass       // (Modifier)* NameIdent TypeParameters? Extends? TsImplementsClause? ClassBody
	TsAmbientEnum        // TsConst? NameIdent TsEnumBody
	TsAmbientExportDecl  // ExportClause
	TsAmbientFunc        // NameIdent TypeParameters? Parameters TypeAnnotation?
	TsAmbientGlobal      // (ModuleItem)*
	TsAmbientImportAlias // TsImportAliasDecl
	TsAmbientInterface   // (Modifier)* NameIdent TypeParameters? TsInterfaceExtends? ObjectType
	TsAmbientModule      // Literal? (NameIdent)* (TsAmbientElement)*
	TsAmbientNamespace   // (NameIdent)+ (TsAmbientElement)*
	TsAmbientTypeAlias   // TypeAliasDecl
	TsAmbientVar         // LetOrConst? Var? (TsAmbientBinding)+
	TsAsConstExpr        // left=Expr TsConst
	TsAsExpr             // left=Expr TsType
	TsCastExpr           // TsType Expr
	TsConditional        // check=TsType ext=TsType truet=TsType falset=TsType
	TsConst
	TsDynamicImport // Arguments
	TsEnum          // TsConst? NameIdent TsEnumBody
	TsEnumBody      // (TsEnumMember)*
	TsEnumMember    // PropertyName Expr?
	TsExclToken
	TsExport
	TsExportAssignment    // Expr
	TsImplementsClause    // (TypeReference)+
	TsImportAliasDecl     // NameIdent ref=(ReferenceIdent)+
	TsImportRequireDecl   // TsExport? NameIdent ModuleSpec
	TsImportTypeStart     // TsImportTypeStart? TsTypeOf? ReferenceIdent? TsType?
	TsIndexMemberDecl     // IndexSignature
	TsInterface           // NameIdent TypeParameters? TsInterfaceExtends? ObjectType
	TsInterfaceExtends    // (TypeReference)+
	TsNamespace           // (NameIdent)+ TsNamespaceBody
	TsNamespaceBody       // (ModuleItem)*
	TsNamespaceExportDecl // NameIdent
	TsNamespaceName       // ref=(ReferenceIdent)+
	TsNonNull             // expr=Expr
	TsOptional
	TsSatisfiesExpr // left=Expr TsType
	TsThisParameter // TypeAnnotation
	TsTypeOf
	TsTypeOnly
	TupleType      // (TupleMember)*
	TypeAliasDecl  // NameIdent TypeParameters? TsType
	TypeAnnotation // TsType
	TypeArguments  // (TsType)+
	TypeConstraint // TsType
	TypeName       // TsNamespaceName? ref=(ReferenceIdent)+
	TypeParameter  // NameIdent TypeConstraint? TsType?
	TypeParameters // (TypeParameter)+
	TypePredicate  // paramref=ReferenceIdent TsType
	TypeQuery      // (ReferenceIdent)+
	TypeReference  // TypeName TypeArguments?
	TypeVar        // NameIdent
	UnaryExpr      // Expr
	UnionType      // inner=(TsType)*
	UniqueType     // TsType
	Var
	VarDecl   // BindingPattern? NameIdent? TsExclToken? TypeAnnotation? Initializer?
	VarStmt   // (VarDecl)+
	WhileStmt // Expr Stmt
	WithStmt  // Expr Stmt
	Yield     // Expr?
	MultiLineComment
	SingleLineComment
	InvalidToken
	NoSubstitutionTemplate
	TemplateHead
	TemplateMiddle
	TemplateTail
	InsertedSemicolon
	NodeTypeMax
)

var nodeTypeStr = [...]string{
	"NONE",
	"Abstract",
	"AccessibilityModifier",
	"Accessor",
	"AdditiveExpr",
	"Arguments",
	"ArrayLiteral",
	"ArrayPattern",
	"ArrayType",
	"ArrowFunc",
	"AssertClause",
	"AssertEntry",
	"AssertionKey",
	"AssertsType",
	"AssignmentExpr",
	"AssignmentOperator",
	"AsyncArrowFunc",
	"AsyncFunc",
	"AsyncFuncExpr",
	"AsyncGeneratorDeclaration",
	"AsyncGeneratorExpression",
	"AsyncGeneratorMethod",
	"AsyncMethod",
	"Await",
	"AwaitExpr",
	"BindingRestElement",
	"BitwiseAND",
	"BitwiseOR",
	"BitwiseXOR",
	"Block",
	"Body",
	"BreakStmt",
	"CallExpr",
	"CallSignature",
	"Case",
	"Catch",
	"Class",
	"ClassBody",
	"ClassExpr",
	"CoalesceExpr",
	"CommaExpr",
	"ComputedPropertyName",
	"ConciseBody",
	"Cond",
	"ConditionalExpr",
	"ConstructSignature",
	"ConstructorType",
	"ContinueStmt",
	"DebuggerStmt",
	"Declare",
	"DecoratorCall",
	"DecoratorExpr",
	"Default",
	"DefaultParameter",
	"DoWhileStmt",
	"ElementBinding",
	"EmptyDecl",
	"EmptyStmt",
	"EqualityExpr",
	"ExponentiationExpr",
	"ExportClause",
	"ExportDecl",
	"ExportDefault",
	"ExportSpec",
	"ExprStmt",
	"Extends",
	"Finally",
	"ForBinding",
	"ForCondition",
	"ForFinalExpr",
	"ForInStmt",
	"ForInStmtWithVar",
	"ForOfStmt",
	"ForOfStmtWithVar",
	"ForStmt",
	"ForStmtWithVar",
	"Func",
	"FuncExpr",
	"FuncType",
	"Generator",
	"GeneratorExpr",
	"GeneratorMethod",
	"Getter",
	"IdentExpr",
	"IfStmt",
	"ImportDecl",
	"ImportSpec",
	"ImportType",
	"InExpr",
	"IndexAccess",
	"IndexSignature",
	"IndexedAccessType",
	"Initializer",
	"InstanceOfExpr",
	"IntersectionType",
	"JSXAttributeName",
	"JSXClosingElement",
	"JSXElement",
	"JSXElementName",
	"JSXExpr",
	"JSXFragment",
	"JSXLiteral",
	"JSXNormalAttribute",
	"JSXOpeningElement",
	"JSXSelfClosingElement",
	"JSXSpreadAttribute",
	"JSXSpreadExpr",
	"JSXText",
	"KeyOfType",
	"LabelIdent",
	"LabelledStmt",
	"LetOrConst",
	"LexicalBinding",
	"LexicalDecl",
	"Literal",
	"LiteralPropertyName",
	"LiteralType",
	"LogicalAND",
	"LogicalOR",
	"MappedType",
	"MemberMethod",
	"MemberVar",
	"Method",
	"MethodSignature",
	"Module",
	"ModuleSpec",
	"MultiplicativeExpr",
	"NameIdent",
	"NameSpaceImport",
	"NamedImports",
	"NamedTupleMember",
	"NewExpr",
	"NewTarget",
	"NoElement",
	"NonNullableType",
	"NotExpr",
	"NullableType",
	"ObjectLiteral",
	"ObjectMethod",
	"ObjectPattern",
	"ObjectType",
	"OptionalCallExpr",
	"OptionalIndexAccess",
	"OptionalPropertyAccess",
	"OptionalTaggedTemplate",
	"Override",
	"Parameters",
	"Parenthesized",
	"ParenthesizedType",
	"PostDec",
	"PostInc",
	"PreDec",
	"PreInc",
	"PredefinedType",
	"Property",
	"PropertyAccess",
	"PropertyBinding",
	"PropertySignature",
	"Readonly",
	"ReadonlyType",
	"ReferenceIdent",
	"Regexp",
	"RelationalExpr",
	"RestParameter",
	"RestType",
	"ReturnStmt",
	"Setter",
	"ShiftExpr",
	"ShorthandProperty",
	"SingleNameBinding",
	"SpreadElement",
	"SpreadProperty",
	"Static",
	"StaticBlock",
	"SuperExpr",
	"SwitchStmt",
	"SyntaxProblem",
	"TaggedTemplate",
	"TemplateLiteral",
	"TemplateLiteralType",
	"This",
	"ThisExpr",
	"ThisType",
	"ThrowStmt",
	"TryStmt",
	"TsAmbientBinding",
	"TsAmbientClass",
	"TsAmbientEnum",
	"TsAmbientExportDecl",
	"TsAmbientFunc",
	"TsAmbientGlobal",
	"TsAmbientImportAlias",
	"TsAmbientInterface",
	"TsAmbientModule",
	"TsAmbientNamespace",
	"TsAmbientTypeAlias",
	"TsAmbientVar",
	"TsAsConstExpr",
	"TsAsExpr",
	"TsCastExpr",
	"TsConditional",
	"TsConst",
	"TsDynamicImport",
	"TsEnum",
	"TsEnumBody",
	"TsEnumMember",
	"TsExclToken",
	"TsExport",
	"TsExportAssignment",
	"TsImplementsClause",
	"TsImportAliasDecl",
	"TsImportRequireDecl",
	"TsImportTypeStart",
	"TsIndexMemberDecl",
	"TsInterface",
	"TsInterfaceExtends",
	"TsNamespace",
	"TsNamespaceBody",
	"TsNamespaceExportDecl",
	"TsNamespaceName",
	"TsNonNull",
	"TsOptional",
	"TsSatisfiesExpr",
	"TsThisParameter",
	"TsTypeOf",
	"TsTypeOnly",
	"TupleType",
	"TypeAliasDecl",
	"TypeAnnotation",
	"TypeArguments",
	"TypeConstraint",
	"TypeName",
	"TypeParameter",
	"TypeParameters",
	"TypePredicate",
	"TypeQuery",
	"TypeReference",
	"TypeVar",
	"UnaryExpr",
	"UnionType",
	"UniqueType",
	"Var",
	"VarDecl",
	"VarStmt",
	"WhileStmt",
	"WithStmt",
	"Yield",
	"MultiLineComment",
	"SingleLineComment",
	"InvalidToken",
	"NoSubstitutionTemplate",
	"TemplateHead",
	"TemplateMiddle",
	"TemplateTail",
	"InsertedSemicolon",
}

func (t NodeType) String() string {
	if t >= 0 && int(t) < len(nodeTypeStr) {
		return nodeTypeStr[t]
	}
	return fmt.Sprintf("node(%d)", t)
}

var BindingPattern = []NodeType{
	ArrayPattern,
	ObjectPattern,
}

var CaseClause = []NodeType{
	Case,
	Default,
}

var ClassElement = []NodeType{
	EmptyDecl,
	MemberMethod,
	MemberVar,
	StaticBlock,
	SyntaxProblem,
	TsIndexMemberDecl,
}

var Decl = []NodeType{
	AsyncFunc,
	AsyncGeneratorDeclaration,
	Class,
	ExportDefault,
	Func,
	Generator,
	ImportDecl,
	LexicalDecl,
	TsAmbientClass,
	TsAmbientEnum,
	TsAmbientExportDecl,
	TsAmbientFunc,
	TsAmbientGlobal,
	TsAmbientImportAlias,
	TsAmbientInterface,
	TsAmbientModule,
	TsAmbientNamespace,
	TsAmbientTypeAlias,
	TsAmbientVar,
	TsEnum,
	TsExportAssignment,
	TsImportAliasDecl,
	TsInterface,
	TsNamespace,
	TypeAliasDecl,
}

var Decorator = []NodeType{
	DecoratorCall,
	DecoratorExpr,
}

var ElementPattern = []NodeType{
	ElementBinding,
	NoElement,
	SingleNameBinding,
	SyntaxProblem,
}

var ExportElement = []NodeType{
	ExportSpec,
	SyntaxProblem,
}

var Expr = []NodeType{
	AdditiveExpr,
	ArrayLiteral,
	ArrowFunc,
	AssignmentExpr,
	AsyncArrowFunc,
	AsyncFuncExpr,
	AsyncGeneratorExpression,
	AwaitExpr,
	BitwiseAND,
	BitwiseOR,
	BitwiseXOR,
	CallExpr,
	ClassExpr,
	CoalesceExpr,
	CommaExpr,
	ConditionalExpr,
	EqualityExpr,
	ExponentiationExpr,
	FuncExpr,
	GeneratorExpr,
	IdentExpr,
	InExpr,
	IndexAccess,
	InstanceOfExpr,
	JSXElement,
	JSXFragment,
	Literal,
	LogicalAND,
	LogicalOR,
	MultiplicativeExpr,
	NewExpr,
	NewTarget,
	NoElement,
	NotExpr,
	ObjectLiteral,
	OptionalCallExpr,
	OptionalIndexAccess,
	OptionalPropertyAccess,
	OptionalTaggedTemplate,
	Parenthesized,
	PostDec,
	PostInc,
	PreDec,
	PreInc,
	PropertyAccess,
	Regexp,
	RelationalExpr,
	ShiftExpr,
	SpreadElement,
	SuperExpr,
	SyntaxProblem,
	TaggedTemplate,
	TemplateLiteral,
	ThisExpr,
	TsAsConstExpr,
	TsAsExpr,
	TsCastExpr,
	TsDynamicImport,
	TsNonNull,
	TsSatisfiesExpr,
	UnaryExpr,
	Yield,
}

var IterationStmt = []NodeType{
	DoWhileStmt,
	ForInStmt,
	ForInStmtWithVar,
	ForOfStmt,
	ForOfStmtWithVar,
	ForStmt,
	ForStmtWithVar,
	WhileStmt,
}

var JSXAttribute = []NodeType{
	JSXNormalAttribute,
	JSXSpreadAttribute,
}

var JSXAttributeValue = []NodeType{
	JSXElement,
	JSXExpr,
	JSXFragment,
	JSXLiteral,
}

var JSXChild = []NodeType{
	JSXElement,
	JSXExpr,
	JSXFragment,
	JSXSpreadExpr,
	JSXText,
}

var MethodDefinition = []NodeType{
	AsyncGeneratorMethod,
	AsyncMethod,
	GeneratorMethod,
	Getter,
	Method,
	Setter,
}

var Modifier = []NodeType{
	Abstract,
	AccessibilityModifier,
	Accessor,
	Declare,
	DecoratorCall,
	DecoratorExpr,
	Override,
	Readonly,
	Static,
}

var ModuleItem = []NodeType{
	AsyncFunc,
	AsyncGeneratorDeclaration,
	Block,
	BreakStmt,
	Class,
	ContinueStmt,
	DebuggerStmt,
	DoWhileStmt,
	EmptyStmt,
	ExportDecl,
	ExportDefault,
	ExprStmt,
	ForInStmt,
	ForInStmtWithVar,
	ForOfStmt,
	ForOfStmtWithVar,
	ForStmt,
	ForStmtWithVar,
	Func,
	Generator,
	IfStmt,
	ImportDecl,
	LabelledStmt,
	LexicalDecl,
	ReturnStmt,
	SwitchStmt,
	SyntaxProblem,
	ThrowStmt,
	TryStmt,
	TsAmbientClass,
	TsAmbientEnum,
	TsAmbientExportDecl,
	TsAmbientFunc,
	TsAmbientGlobal,
	TsAmbientImportAlias,
	TsAmbientInterface,
	TsAmbientModule,
	TsAmbientNamespace,
	TsAmbientTypeAlias,
	TsAmbientVar,
	TsEnum,
	TsExportAssignment,
	TsImportAliasDecl,
	TsImportRequireDecl,
	TsInterface,
	TsNamespace,
	TsNamespaceExportDecl,
	TypeAliasDecl,
	VarStmt,
	WhileStmt,
	WithStmt,
}

var NamedImport = []NodeType{
	ImportSpec,
	SyntaxProblem,
}

var Parameter = []NodeType{
	DefaultParameter,
	RestParameter,
	SyntaxProblem,
	TsThisParameter,
}

var PropertyDefinition = []NodeType{
	ObjectMethod,
	Property,
	ShorthandProperty,
	SpreadProperty,
	SyntaxProblem,
}

var PropertyName = []NodeType{
	ComputedPropertyName,
	LiteralPropertyName,
}

var PropertyPattern = []NodeType{
	PropertyBinding,
	SingleNameBinding,
	SyntaxProblem,
}

var Stmt = []NodeType{
	Block,
	BreakStmt,
	ContinueStmt,
	DebuggerStmt,
	DoWhileStmt,
	EmptyStmt,
	ExprStmt,
	ForInStmt,
	ForInStmtWithVar,
	ForOfStmt,
	ForOfStmtWithVar,
	ForStmt,
	ForStmtWithVar,
	IfStmt,
	LabelledStmt,
	ReturnStmt,
	SwitchStmt,
	ThrowStmt,
	TryStmt,
	VarStmt,
	WhileStmt,
	WithStmt,
}

var StmtListItem = []NodeType{
	AsyncFunc,
	AsyncGeneratorDeclaration,
	Block,
	BreakStmt,
	Class,
	ContinueStmt,
	DebuggerStmt,
	DoWhileStmt,
	EmptyStmt,
	ExportDefault,
	ExprStmt,
	ForInStmt,
	ForInStmtWithVar,
	ForOfStmt,
	ForOfStmtWithVar,
	ForStmt,
	ForStmtWithVar,
	Func,
	Generator,
	IfStmt,
	ImportDecl,
	LabelledStmt,
	LexicalDecl,
	ReturnStmt,
	SwitchStmt,
	SyntaxProblem,
	ThrowStmt,
	TryStmt,
	TsAmbientClass,
	TsAmbientEnum,
	TsAmbientExportDecl,
	TsAmbientFunc,
	TsAmbientGlobal,
	TsAmbientImportAlias,
	TsAmbientInterface,
	TsAmbientModule,
	TsAmbientNamespace,
	TsAmbientTypeAlias,
	TsAmbientVar,
	TsEnum,
	TsExportAssignment,
	TsImportAliasDecl,
	TsInterface,
	TsNamespace,
	TypeAliasDecl,
	VarStmt,
	WhileStmt,
	WithStmt,
}

var TokenSet = []NodeType{
	NoSubstitutionTemplate,
	TemplateHead,
	TemplateMiddle,
	TemplateTail,
}

var TsAmbientElement = []NodeType{
	ExportDefault,
	ImportDecl,
	TsAmbientClass,
	TsAmbientEnum,
	TsAmbientExportDecl,
	TsAmbientFunc,
	TsAmbientGlobal,
	TsAmbientImportAlias,
	TsAmbientInterface,
	TsAmbientModule,
	TsAmbientNamespace,
	TsAmbientTypeAlias,
	TsAmbientVar,
	TsExportAssignment,
}

var TsType = []NodeType{
	ArrayType,
	AssertsType,
	ConstructorType,
	FuncType,
	ImportType,
	IndexedAccessType,
	IntersectionType,
	KeyOfType,
	LiteralType,
	MappedType,
	NonNullableType,
	NullableType,
	ObjectType,
	ParenthesizedType,
	PredefinedType,
	ReadonlyType,
	RestType,
	ThisType,
	TsConditional,
	TupleType,
	TypePredicate,
	TypeQuery,
	TypeReference,
	TypeVar,
	UnionType,
	UniqueType,
}

var TupleMember = []NodeType{
	ArrayType,
	AssertsType,
	ConstructorType,
	FuncType,
	ImportType,
	IndexedAccessType,
	IntersectionType,
	KeyOfType,
	LiteralType,
	MappedType,
	NamedTupleMember,
	NonNullableType,
	NullableType,
	ObjectType,
	ParenthesizedType,
	PredefinedType,
	ReadonlyType,
	RestType,
	ThisType,
	TsConditional,
	TupleType,
	TypePredicate,
	TypeQuery,
	TypeReference,
	TypeVar,
	UnionType,
	UniqueType,
}

var TypeMember = []NodeType{
	CallSignature,
	ConstructSignature,
	Getter,
	IndexSignature,
	MethodSignature,
	PropertySignature,
	Setter,
	SyntaxProblem,
}
