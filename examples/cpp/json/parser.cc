// generated by John please edit

#include "parser.h"

#include <cstdint>
#include <string>

#include "lexer.h"
#include "absl/strings/str_format.h"

namespace json {

constexpr inline absl::string_view tmNonterminals[] = {
    "JSONText",
    "JSONValue",
    "JSONValue_A",
    "EmptyObject",
    "lookahead_EmptyObject",
    "JSONObject",
    "lookahead_notEmptyObject",
    "JSONMember",
    "JSONMemberList",
    "JSONArray",
    "JSONElementList",
    "JSONElementListopt",
};
constexpr size_t tmNonterminalsLen =
    sizeof(tmNonterminals) / sizeof(tmNonterminals[0]);

std::string symbolName(int32_t sym) {
  if (sym == noToken) {
    return "<no-token>";
  }
  if (sym >= 0 && sym < static_cast<int32_t>(Token::NumTokens)) {
    return std::string(tokenStr[sym]);
  }
  if (sym >= static_cast<int32_t>(Token::NumTokens) &&
      sym - static_cast<int32_t>(Token::NumTokens) < tmNonterminalsLen) {
    return std::string(
        tmNonterminals[sym - static_cast<int32_t>(Token::NumTokens)]);
  }
  return absl::StrFormat("nonterminal(%d)", sym);
}

constexpr int32_t tmAction[] = {
    20, -3, -1,  -21, 17, 18, 10,  11, 12, 13, 0,  15, 14, -1,  16,
    -1, 28, -41, -1,  -1, 19, -47, 27, 22, -1, 25, -1, 29, -65, 21,
    -1, 8,  9,   1,   2,  3,  4,   24, 6,  5,  7,  26, -2, -1,  -2,
};

constexpr int32_t tmLalr[] = {
    4,  -1, 10, -1, 11, -1, 13, -1, 14, -1, 15, -1, 16, -1, 2,  32,
    -1, -2, 4,  -1, 10, -1, 11, -1, 13, -1, 14, -1, 15, -1, 16, -1,
    2,  32, 5,  31, -1, -2, 7,  -1, 5,  30, -1, -2, 4,  -1, 10, -1,
    11, -1, 13, -1, 14, -1, 15, -1, 16, -1, 2,  32, -1, -2, 4,  -1,
    10, -1, 11, -1, 13, -1, 14, -1, 15, -1, 17, -1, 2,  32, -1, -2,
};

constexpr int32_t tmGoto[] = {
    0,  2,  2,  6,  12, 20, 22, 24,  28,  28,  28,  40,  48,  48,  56,  64,
    72, 78, 80, 80, 82, 84, 90, 100, 110, 118, 126, 130, 132, 140, 142, 144,
};

constexpr int8_t tmFromTo[] = {
    43, 44, 2,  15, 13, 19, 15, 20, 19, 23, 26, 29, 1,  3,  3,  3,  21, 3,
    28, 3,  18, 22, 24, 28, 17, 21, 26, 30, 1,  4,  3,  4,  19, 24, 21, 4,
    28, 31, 30, 24, 1,  5,  3,  5,  21, 5,  28, 32, 1,  6,  3,  6,  21, 6,
    28, 33, 1,  7,  3,  7,  21, 7,  28, 34, 1,  8,  3,  8,  21, 8,  28, 35,
    1,  9,  3,  9,  21, 9,  28, 36, 1,  43, 28, 37, 1,  10, 3,  16, 21, 27,
    0,  42, 1,  11, 3,  11, 21, 11, 28, 38, 0,  2,  1,  2,  3,  2,  21, 2,
    28, 2,  1,  12, 3,  12, 21, 12, 28, 39, 1,  13, 3,  13, 21, 13, 28, 13,
    19, 25, 30, 41, 19, 26, 1,  14, 3,  14, 21, 14, 28, 40, 3,  17, 3,  18,
};

constexpr int8_t tmRuleLen[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 3, 0, 4, 3, 0, 3, 1, 3, 3, 1, 3, 1, 0, 0,
};

constexpr int32_t tmRuleSymbol[] = {
    19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
    21, 21, 22, 23, 24, 24, 25, 26, 27, 27, 28, 29, 29, 30, 30, 25,
};

constexpr NodeType tmRuleType[] = {
    NodeType::JSONText,     // JSONText : JSONValue_A
    NodeType::JSONValue,    // JSONValue : 'null'
    NodeType::JSONValue,    // JSONValue : 'true'
    NodeType::JSONValue,    // JSONValue : 'false'
    NodeType::JSONValue,    // JSONValue : 'B'
    NodeType::JSONValue,    // JSONValue : JSONObject
    NodeType::JSONValue,    // JSONValue : EmptyObject
    NodeType::JSONValue,    // JSONValue : JSONArray
    NodeType::JSONValue,    // JSONValue : JSONString
    NodeType::JSONValue,    // JSONValue : JSONNumber
    NodeType::JSONValue,    // JSONValue_A : 'null'
    NodeType::JSONValue,    // JSONValue_A : 'true'
    NodeType::JSONValue,    // JSONValue_A : 'false'
    NodeType::JSONValue,    // JSONValue_A : 'A'
    NodeType::JSONValue,    // JSONValue_A : JSONObject
    NodeType::JSONValue,    // JSONValue_A : EmptyObject
    NodeType::JSONValue,    // JSONValue_A : JSONArray
    NodeType::JSONValue,    // JSONValue_A : JSONString
    NodeType::JSONValue,    // JSONValue_A : JSONNumber
    NodeType::EmptyObject,  // EmptyObject : lookahead_EmptyObject '{' '}'
    NodeType::NoType,       // lookahead_EmptyObject :
    NodeType::JSONObject,   // JSONObject : lookahead_notEmptyObject '{'
                            // JSONMemberList '}'
    NodeType::JSONObject,   // JSONObject : lookahead_notEmptyObject '{' '}'
    NodeType::NoType,       // lookahead_notEmptyObject :
    NodeType::JSONMember,   // JSONMember : JSONString ':' JSONValue
    NodeType::NoType,       // JSONMemberList : JSONMember
    NodeType::NoType,       // JSONMemberList : JSONMemberList ',' JSONMember
    NodeType::JSONArray,    // JSONArray : '[' JSONElementListopt ']'
    NodeType::NoType,       // JSONElementList : JSONValue_A
    NodeType::NoType,       // JSONElementList : JSONElementList ',' JSONValue_A
    NodeType::NoType,       // JSONElementListopt : JSONElementList
    NodeType::NoType,       // JSONElementListopt :
};

// set(first JSONValue_A) = LBRACE, LBRACK, JSONSTRING, JSONNUMBER, NULL, TRUE,
// FALSE, CHAR_A
[[maybe_unused]] constexpr int32_t Literals[] = {
    2, 4, 10, 11, 13, 14, 15, 16,
};

// set(follow error) =
[[maybe_unused]] constexpr int32_t afterErr[] = {};

int32_t lalr(int32_t action, int32_t next) {
  int32_t a = -action - 3;
  for (; tmLalr[a] >= 0; a += 2) {
    if (tmLalr[a] == next) {
      break;
    }
  }
  return tmLalr[a + 1];
}

int8_t gotoState(int8_t state, int32_t symbol) {
  int32_t min = tmGoto[symbol];
  int32_t max = tmGoto[symbol + 1];

  if (max - min < 32) {
    for (auto i = min; i < max; i += 2) {
      if (tmFromTo[i] == state) {
        return tmFromTo[i + 1];
      }
    }
  } else {
    while (min < max) {
      int32_t e = ((min + max) / 2) & ~static_cast<int32_t>(1);
      int8_t i = tmFromTo[e];
      if (i == state) {
        return tmFromTo[e + 1];
      } else if (i < state) {
        min = e + 2;
      } else {
        max = e;
      }
    }
  }
  return -1;
}

void Parser::reportIgnoredToken(symbol sym) {
  NodeType t;
  switch (Token(sym.symbol)) {
    case Token::MULTILINECOMMENT:
      t = NodeType::MultiLineComment;
      break;
    case Token::INVALID_TOKEN:
      t = NodeType::InvalidToken;
      break;
    default:
      return;
  }
  if (debugSyntax) {
    LOG(INFO) << "ignored: " << Token(sym.symbol) << " as " << t;
  }
  listener_(t, sym.offset, sym.endoffset);
}
}  // namespace json
