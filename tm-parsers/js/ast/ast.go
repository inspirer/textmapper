// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/inspirer/textmapper/tm-parsers/js"
	"github.com/inspirer/textmapper/tm-parsers/js/selector"
)

// Interfaces.

type JsNode interface {
	JsNode() *Node
}

type Token struct {
	*Node
}

type NilNode struct{}

var nilInstance = &NilNode{}

// All types implement JsNode.
func (n Abstract) JsNode() *Node               { return n.Node }
func (n AccessibilityModifier) JsNode() *Node  { return n.Node }
func (n AdditiveExpr) JsNode() *Node           { return n.Node }
func (n Arguments) JsNode() *Node              { return n.Node }
func (n ArrayLiteral) JsNode() *Node           { return n.Node }
func (n ArrayPattern) JsNode() *Node           { return n.Node }
func (n ArrayType) JsNode() *Node              { return n.Node }
func (n ArrowFunc) JsNode() *Node              { return n.Node }
func (n AssertsType) JsNode() *Node            { return n.Node }
func (n AssignmentExpr) JsNode() *Node         { return n.Node }
func (n AssignmentOperator) JsNode() *Node     { return n.Node }
func (n AsyncArrowFunc) JsNode() *Node         { return n.Node }
func (n AsyncFunc) JsNode() *Node              { return n.Node }
func (n AsyncFuncExpr) JsNode() *Node          { return n.Node }
func (n AsyncMethod) JsNode() *Node            { return n.Node }
func (n AwaitExpr) JsNode() *Node              { return n.Node }
func (n BindingRestElement) JsNode() *Node     { return n.Node }
func (n BitwiseAND) JsNode() *Node             { return n.Node }
func (n BitwiseOR) JsNode() *Node              { return n.Node }
func (n BitwiseXOR) JsNode() *Node             { return n.Node }
func (n Block) JsNode() *Node                  { return n.Node }
func (n Body) JsNode() *Node                   { return n.Node }
func (n BreakStmt) JsNode() *Node              { return n.Node }
func (n CallExpr) JsNode() *Node               { return n.Node }
func (n CallSignature) JsNode() *Node          { return n.Node }
func (n Case) JsNode() *Node                   { return n.Node }
func (n Catch) JsNode() *Node                  { return n.Node }
func (n Class) JsNode() *Node                  { return n.Node }
func (n ClassBody) JsNode() *Node              { return n.Node }
func (n ClassExpr) JsNode() *Node              { return n.Node }
func (n CoalesceExpr) JsNode() *Node           { return n.Node }
func (n CommaExpr) JsNode() *Node              { return n.Node }
func (n ComputedPropertyName) JsNode() *Node   { return n.Node }
func (n ConciseBody) JsNode() *Node            { return n.Node }
func (n ConditionalExpr) JsNode() *Node        { return n.Node }
func (n ConstructSignature) JsNode() *Node     { return n.Node }
func (n ConstructorType) JsNode() *Node        { return n.Node }
func (n ContinueStmt) JsNode() *Node           { return n.Node }
func (n DebuggerStmt) JsNode() *Node           { return n.Node }
func (n Declare) JsNode() *Node                { return n.Node }
func (n DecoratorCall) JsNode() *Node          { return n.Node }
func (n DecoratorExpr) JsNode() *Node          { return n.Node }
func (n Default) JsNode() *Node                { return n.Node }
func (n DefaultParameter) JsNode() *Node       { return n.Node }
func (n DoWhileStmt) JsNode() *Node            { return n.Node }
func (n ElementBinding) JsNode() *Node         { return n.Node }
func (n EmptyDecl) JsNode() *Node              { return n.Node }
func (n EmptyStmt) JsNode() *Node              { return n.Node }
func (n EqualityExpr) JsNode() *Node           { return n.Node }
func (n ExponentiationExpr) JsNode() *Node     { return n.Node }
func (n ExportClause) JsNode() *Node           { return n.Node }
func (n ExportDecl) JsNode() *Node             { return n.Node }
func (n ExportDefault) JsNode() *Node          { return n.Node }
func (n ExportSpec) JsNode() *Node             { return n.Node }
func (n ExprStmt) JsNode() *Node               { return n.Node }
func (n Extends) JsNode() *Node                { return n.Node }
func (n Finally) JsNode() *Node                { return n.Node }
func (n ForBinding) JsNode() *Node             { return n.Node }
func (n ForCondition) JsNode() *Node           { return n.Node }
func (n ForFinalExpr) JsNode() *Node           { return n.Node }
func (n ForInStmt) JsNode() *Node              { return n.Node }
func (n ForInStmtWithVar) JsNode() *Node       { return n.Node }
func (n ForOfStmt) JsNode() *Node              { return n.Node }
func (n ForOfStmtWithVar) JsNode() *Node       { return n.Node }
func (n ForStmt) JsNode() *Node                { return n.Node }
func (n ForStmtWithVar) JsNode() *Node         { return n.Node }
func (n Func) JsNode() *Node                   { return n.Node }
func (n FuncExpr) JsNode() *Node               { return n.Node }
func (n FuncType) JsNode() *Node               { return n.Node }
func (n Generator) JsNode() *Node              { return n.Node }
func (n GeneratorExpr) JsNode() *Node          { return n.Node }
func (n GeneratorMethod) JsNode() *Node        { return n.Node }
func (n Getter) JsNode() *Node                 { return n.Node }
func (n IdentExpr) JsNode() *Node              { return n.Node }
func (n IfStmt) JsNode() *Node                 { return n.Node }
func (n ImportDecl) JsNode() *Node             { return n.Node }
func (n ImportSpec) JsNode() *Node             { return n.Node }
func (n ImportType) JsNode() *Node             { return n.Node }
func (n InExpr) JsNode() *Node                 { return n.Node }
func (n IndexAccess) JsNode() *Node            { return n.Node }
func (n IndexSignature) JsNode() *Node         { return n.Node }
func (n IndexedAccessType) JsNode() *Node      { return n.Node }
func (n Initializer) JsNode() *Node            { return n.Node }
func (n InstanceOfExpr) JsNode() *Node         { return n.Node }
func (n IntersectionType) JsNode() *Node       { return n.Node }
func (n JSXAttributeName) JsNode() *Node       { return n.Node }
func (n JSXClosingElement) JsNode() *Node      { return n.Node }
func (n JSXElement) JsNode() *Node             { return n.Node }
func (n JSXElementName) JsNode() *Node         { return n.Node }
func (n JSXExpr) JsNode() *Node                { return n.Node }
func (n JSXLiteral) JsNode() *Node             { return n.Node }
func (n JSXNormalAttribute) JsNode() *Node     { return n.Node }
func (n JSXOpeningElement) JsNode() *Node      { return n.Node }
func (n JSXSelfClosingElement) JsNode() *Node  { return n.Node }
func (n JSXSpreadAttribute) JsNode() *Node     { return n.Node }
func (n JSXSpreadExpr) JsNode() *Node          { return n.Node }
func (n JSXText) JsNode() *Node                { return n.Node }
func (n KeyOfType) JsNode() *Node              { return n.Node }
func (n LabelIdent) JsNode() *Node             { return n.Node }
func (n LabelledStmt) JsNode() *Node           { return n.Node }
func (n LetOrConst) JsNode() *Node             { return n.Node }
func (n LexicalBinding) JsNode() *Node         { return n.Node }
func (n LexicalDecl) JsNode() *Node            { return n.Node }
func (n Literal) JsNode() *Node                { return n.Node }
func (n LiteralPropertyName) JsNode() *Node    { return n.Node }
func (n LiteralType) JsNode() *Node            { return n.Node }
func (n LogicalAND) JsNode() *Node             { return n.Node }
func (n LogicalOR) JsNode() *Node              { return n.Node }
func (n MappedType) JsNode() *Node             { return n.Node }
func (n MemberMethod) JsNode() *Node           { return n.Node }
func (n MemberVar) JsNode() *Node              { return n.Node }
func (n Method) JsNode() *Node                 { return n.Node }
func (n MethodSignature) JsNode() *Node        { return n.Node }
func (n Module) JsNode() *Node                 { return n.Node }
func (n ModuleSpec) JsNode() *Node             { return n.Node }
func (n MultiplicativeExpr) JsNode() *Node     { return n.Node }
func (n NameIdent) JsNode() *Node              { return n.Node }
func (n NameSpaceImport) JsNode() *Node        { return n.Node }
func (n NamedImports) JsNode() *Node           { return n.Node }
func (n NewExpr) JsNode() *Node                { return n.Node }
func (n NewTarget) JsNode() *Node              { return n.Node }
func (n NoElement) JsNode() *Node              { return n.Node }
func (n NonNullableType) JsNode() *Node        { return n.Node }
func (n NullableType) JsNode() *Node           { return n.Node }
func (n ObjectLiteral) JsNode() *Node          { return n.Node }
func (n ObjectMethod) JsNode() *Node           { return n.Node }
func (n ObjectPattern) JsNode() *Node          { return n.Node }
func (n ObjectType) JsNode() *Node             { return n.Node }
func (n OptionalCallExpr) JsNode() *Node       { return n.Node }
func (n OptionalIndexAccess) JsNode() *Node    { return n.Node }
func (n OptionalPropertyAccess) JsNode() *Node { return n.Node }
func (n OptionalTaggedTemplate) JsNode() *Node { return n.Node }
func (n Parameters) JsNode() *Node             { return n.Node }
func (n Parenthesized) JsNode() *Node          { return n.Node }
func (n ParenthesizedType) JsNode() *Node      { return n.Node }
func (n PostDec) JsNode() *Node                { return n.Node }
func (n PostInc) JsNode() *Node                { return n.Node }
func (n PreDec) JsNode() *Node                 { return n.Node }
func (n PreInc) JsNode() *Node                 { return n.Node }
func (n PredefinedType) JsNode() *Node         { return n.Node }
func (n Property) JsNode() *Node               { return n.Node }
func (n PropertyAccess) JsNode() *Node         { return n.Node }
func (n PropertyBinding) JsNode() *Node        { return n.Node }
func (n PropertySignature) JsNode() *Node      { return n.Node }
func (n Readonly) JsNode() *Node               { return n.Node }
func (n ReadonlyType) JsNode() *Node           { return n.Node }
func (n ReferenceIdent) JsNode() *Node         { return n.Node }
func (n Regexp) JsNode() *Node                 { return n.Node }
func (n RelationalExpr) JsNode() *Node         { return n.Node }
func (n RestParameter) JsNode() *Node          { return n.Node }
func (n RestType) JsNode() *Node               { return n.Node }
func (n ReturnStmt) JsNode() *Node             { return n.Node }
func (n Setter) JsNode() *Node                 { return n.Node }
func (n ShiftExpr) JsNode() *Node              { return n.Node }
func (n ShorthandProperty) JsNode() *Node      { return n.Node }
func (n SingleNameBinding) JsNode() *Node      { return n.Node }
func (n SpreadElement) JsNode() *Node          { return n.Node }
func (n SpreadProperty) JsNode() *Node         { return n.Node }
func (n Static) JsNode() *Node                 { return n.Node }
func (n SuperExpr) JsNode() *Node              { return n.Node }
func (n SwitchStmt) JsNode() *Node             { return n.Node }
func (n SyntaxProblem) JsNode() *Node          { return n.Node }
func (n TaggedTemplate) JsNode() *Node         { return n.Node }
func (n TemplateLiteral) JsNode() *Node        { return n.Node }
func (n This) JsNode() *Node                   { return n.Node }
func (n ThisType) JsNode() *Node               { return n.Node }
func (n ThrowStmt) JsNode() *Node              { return n.Node }
func (n TryStmt) JsNode() *Node                { return n.Node }
func (n TsAmbientBinding) JsNode() *Node       { return n.Node }
func (n TsAmbientClass) JsNode() *Node         { return n.Node }
func (n TsAmbientEnum) JsNode() *Node          { return n.Node }
func (n TsAmbientExportDecl) JsNode() *Node    { return n.Node }
func (n TsAmbientFunc) JsNode() *Node          { return n.Node }
func (n TsAmbientGlobal) JsNode() *Node        { return n.Node }
func (n TsAmbientImportAlias) JsNode() *Node   { return n.Node }
func (n TsAmbientInterface) JsNode() *Node     { return n.Node }
func (n TsAmbientModule) JsNode() *Node        { return n.Node }
func (n TsAmbientNamespace) JsNode() *Node     { return n.Node }
func (n TsAmbientTypeAlias) JsNode() *Node     { return n.Node }
func (n TsAmbientVar) JsNode() *Node           { return n.Node }
func (n TsAsConstExpr) JsNode() *Node          { return n.Node }
func (n TsAsExpr) JsNode() *Node               { return n.Node }
func (n TsCastExpr) JsNode() *Node             { return n.Node }
func (n TsConditional) JsNode() *Node          { return n.Node }
func (n TsConst) JsNode() *Node                { return n.Node }
func (n TsDynamicImport) JsNode() *Node        { return n.Node }
func (n TsEnum) JsNode() *Node                 { return n.Node }
func (n TsEnumBody) JsNode() *Node             { return n.Node }
func (n TsEnumMember) JsNode() *Node           { return n.Node }
func (n TsExclToken) JsNode() *Node            { return n.Node }
func (n TsExport) JsNode() *Node               { return n.Node }
func (n TsExportAssignment) JsNode() *Node     { return n.Node }
func (n TsImplementsClause) JsNode() *Node     { return n.Node }
func (n TsImportAliasDecl) JsNode() *Node      { return n.Node }
func (n TsImportRequireDecl) JsNode() *Node    { return n.Node }
func (n TsIndexMemberDecl) JsNode() *Node      { return n.Node }
func (n TsInterface) JsNode() *Node            { return n.Node }
func (n TsInterfaceExtends) JsNode() *Node     { return n.Node }
func (n TsNamespace) JsNode() *Node            { return n.Node }
func (n TsNamespaceBody) JsNode() *Node        { return n.Node }
func (n TsNamespaceExportDecl) JsNode() *Node  { return n.Node }
func (n TsNonNull) JsNode() *Node              { return n.Node }
func (n TsThisParameter) JsNode() *Node        { return n.Node }
func (n TsTypeOnly) JsNode() *Node             { return n.Node }
func (n TupleType) JsNode() *Node              { return n.Node }
func (n TypeAliasDecl) JsNode() *Node          { return n.Node }
func (n TypeAnnotation) JsNode() *Node         { return n.Node }
func (n TypeArguments) JsNode() *Node          { return n.Node }
func (n TypeConstraint) JsNode() *Node         { return n.Node }
func (n TypeName) JsNode() *Node               { return n.Node }
func (n TypeParameter) JsNode() *Node          { return n.Node }
func (n TypeParameters) JsNode() *Node         { return n.Node }
func (n TypePredicate) JsNode() *Node          { return n.Node }
func (n TypeQuery) JsNode() *Node              { return n.Node }
func (n TypeReference) JsNode() *Node          { return n.Node }
func (n TypeVar) JsNode() *Node                { return n.Node }
func (n UnaryExpr) JsNode() *Node              { return n.Node }
func (n UnionType) JsNode() *Node              { return n.Node }
func (n UniqueType) JsNode() *Node             { return n.Node }
func (n Var) JsNode() *Node                    { return n.Node }
func (n VarDecl) JsNode() *Node                { return n.Node }
func (n VarStmt) JsNode() *Node                { return n.Node }
func (n WhileStmt) JsNode() *Node              { return n.Node }
func (n WithStmt) JsNode() *Node               { return n.Node }
func (n Yield) JsNode() *Node                  { return n.Node }
func (n InsertedSemicolon) JsNode() *Node      { return n.Node }
func (n Token) JsNode() *Node                  { return n.Node }
func (NilNode) JsNode() *Node                  { return nil }

type BindingPattern interface {
	JsNode
	bindingPatternNode()
}

// bindingPatternNode() ensures that only the following types can be
// assigned to BindingPattern.
//
func (ArrayPattern) bindingPatternNode()  {}
func (ObjectPattern) bindingPatternNode() {}
func (NilNode) bindingPatternNode()       {}

type CaseClause interface {
	JsNode
	caseClauseNode()
}

// caseClauseNode() ensures that only the following types can be
// assigned to CaseClause.
//
func (Case) caseClauseNode()    {}
func (Default) caseClauseNode() {}
func (NilNode) caseClauseNode() {}

type ClassElement interface {
	JsNode
	classElementNode()
}

// classElementNode() ensures that only the following types can be
// assigned to ClassElement.
//
func (EmptyDecl) classElementNode()         {}
func (MemberMethod) classElementNode()      {}
func (MemberVar) classElementNode()         {}
func (TsIndexMemberDecl) classElementNode() {}
func (NilNode) classElementNode()           {}

type Decl interface {
	JsNode
	declNode()
}

// declNode() ensures that only the following types can be
// assigned to Decl.
//
func (AsyncFunc) declNode()            {}
func (Class) declNode()                {}
func (Func) declNode()                 {}
func (Generator) declNode()            {}
func (LexicalDecl) declNode()          {}
func (TsAmbientClass) declNode()       {}
func (TsAmbientEnum) declNode()        {}
func (TsAmbientExportDecl) declNode()  {}
func (TsAmbientFunc) declNode()        {}
func (TsAmbientGlobal) declNode()      {}
func (TsAmbientImportAlias) declNode() {}
func (TsAmbientInterface) declNode()   {}
func (TsAmbientModule) declNode()      {}
func (TsAmbientNamespace) declNode()   {}
func (TsAmbientTypeAlias) declNode()   {}
func (TsAmbientVar) declNode()         {}
func (TsEnum) declNode()               {}
func (TsImportAliasDecl) declNode()    {}
func (TsInterface) declNode()          {}
func (TsNamespace) declNode()          {}
func (TypeAliasDecl) declNode()        {}
func (NilNode) declNode()              {}

type Decorator interface {
	JsNode
	decoratorNode()
}

// decoratorNode() ensures that only the following types can be
// assigned to Decorator.
//
func (DecoratorCall) decoratorNode() {}
func (DecoratorExpr) decoratorNode() {}
func (NilNode) decoratorNode()       {}

type ElementPattern interface {
	JsNode
	elementPatternNode()
}

// elementPatternNode() ensures that only the following types can be
// assigned to ElementPattern.
//
func (ElementBinding) elementPatternNode()    {}
func (NoElement) elementPatternNode()         {}
func (SingleNameBinding) elementPatternNode() {}
func (SyntaxProblem) elementPatternNode()     {}
func (NilNode) elementPatternNode()           {}

type ExportElement interface {
	JsNode
	exportElementNode()
}

// exportElementNode() ensures that only the following types can be
// assigned to ExportElement.
//
func (ExportSpec) exportElementNode()    {}
func (SyntaxProblem) exportElementNode() {}
func (NilNode) exportElementNode()       {}

type Expr interface {
	JsNode
	exprNode()
}

// exprNode() ensures that only the following types can be
// assigned to Expr.
//
func (AdditiveExpr) exprNode()           {}
func (ArrayLiteral) exprNode()           {}
func (ArrowFunc) exprNode()              {}
func (AssignmentExpr) exprNode()         {}
func (AsyncArrowFunc) exprNode()         {}
func (AsyncFuncExpr) exprNode()          {}
func (AwaitExpr) exprNode()              {}
func (BitwiseAND) exprNode()             {}
func (BitwiseOR) exprNode()              {}
func (BitwiseXOR) exprNode()             {}
func (CallExpr) exprNode()               {}
func (ClassExpr) exprNode()              {}
func (CoalesceExpr) exprNode()           {}
func (CommaExpr) exprNode()              {}
func (ConditionalExpr) exprNode()        {}
func (EqualityExpr) exprNode()           {}
func (ExponentiationExpr) exprNode()     {}
func (FuncExpr) exprNode()               {}
func (GeneratorExpr) exprNode()          {}
func (IdentExpr) exprNode()              {}
func (InExpr) exprNode()                 {}
func (IndexAccess) exprNode()            {}
func (InstanceOfExpr) exprNode()         {}
func (JSXElement) exprNode()             {}
func (Literal) exprNode()                {}
func (LogicalAND) exprNode()             {}
func (LogicalOR) exprNode()              {}
func (MultiplicativeExpr) exprNode()     {}
func (NewExpr) exprNode()                {}
func (NewTarget) exprNode()              {}
func (NoElement) exprNode()              {}
func (ObjectLiteral) exprNode()          {}
func (OptionalCallExpr) exprNode()       {}
func (OptionalIndexAccess) exprNode()    {}
func (OptionalPropertyAccess) exprNode() {}
func (OptionalTaggedTemplate) exprNode() {}
func (Parenthesized) exprNode()          {}
func (PostDec) exprNode()                {}
func (PostInc) exprNode()                {}
func (PreDec) exprNode()                 {}
func (PreInc) exprNode()                 {}
func (PropertyAccess) exprNode()         {}
func (Regexp) exprNode()                 {}
func (RelationalExpr) exprNode()         {}
func (ShiftExpr) exprNode()              {}
func (SpreadElement) exprNode()          {}
func (SuperExpr) exprNode()              {}
func (TaggedTemplate) exprNode()         {}
func (TemplateLiteral) exprNode()        {}
func (This) exprNode()                   {}
func (TsAsConstExpr) exprNode()          {}
func (TsAsExpr) exprNode()               {}
func (TsCastExpr) exprNode()             {}
func (TsDynamicImport) exprNode()        {}
func (TsNonNull) exprNode()              {}
func (UnaryExpr) exprNode()              {}
func (Yield) exprNode()                  {}
func (NilNode) exprNode()                {}

type IterationStmt interface {
	JsNode
	iterationStmtNode()
}

// iterationStmtNode() ensures that only the following types can be
// assigned to IterationStmt.
//
func (DoWhileStmt) iterationStmtNode()      {}
func (ForInStmt) iterationStmtNode()        {}
func (ForInStmtWithVar) iterationStmtNode() {}
func (ForOfStmt) iterationStmtNode()        {}
func (ForOfStmtWithVar) iterationStmtNode() {}
func (ForStmt) iterationStmtNode()          {}
func (ForStmtWithVar) iterationStmtNode()   {}
func (WhileStmt) iterationStmtNode()        {}
func (NilNode) iterationStmtNode()          {}

type JSXAttribute interface {
	JsNode
	jSXAttributeNode()
}

// jSXAttributeNode() ensures that only the following types can be
// assigned to JSXAttribute.
//
func (JSXNormalAttribute) jSXAttributeNode() {}
func (JSXSpreadAttribute) jSXAttributeNode() {}
func (NilNode) jSXAttributeNode()            {}

type JSXAttributeValue interface {
	JsNode
	jSXAttributeValueNode()
}

// jSXAttributeValueNode() ensures that only the following types can be
// assigned to JSXAttributeValue.
//
func (JSXElement) jSXAttributeValueNode() {}
func (JSXExpr) jSXAttributeValueNode()    {}
func (JSXLiteral) jSXAttributeValueNode() {}
func (NilNode) jSXAttributeValueNode()    {}

type JSXChild interface {
	JsNode
	jSXChildNode()
}

// jSXChildNode() ensures that only the following types can be
// assigned to JSXChild.
//
func (JSXElement) jSXChildNode()    {}
func (JSXExpr) jSXChildNode()       {}
func (JSXSpreadExpr) jSXChildNode() {}
func (JSXText) jSXChildNode()       {}
func (NilNode) jSXChildNode()       {}

type MethodDefinition interface {
	JsNode
	methodDefinitionNode()
}

// methodDefinitionNode() ensures that only the following types can be
// assigned to MethodDefinition.
//
func (AsyncMethod) methodDefinitionNode()     {}
func (GeneratorMethod) methodDefinitionNode() {}
func (Getter) methodDefinitionNode()          {}
func (Method) methodDefinitionNode()          {}
func (Setter) methodDefinitionNode()          {}
func (NilNode) methodDefinitionNode()         {}

type Modifier interface {
	JsNode
	modifierNode()
}

// modifierNode() ensures that only the following types can be
// assigned to Modifier.
//
func (Abstract) modifierNode()              {}
func (AccessibilityModifier) modifierNode() {}
func (Declare) modifierNode()               {}
func (DecoratorCall) modifierNode()         {}
func (DecoratorExpr) modifierNode()         {}
func (Readonly) modifierNode()              {}
func (Static) modifierNode()                {}
func (NilNode) modifierNode()               {}

type ModuleItem interface {
	JsNode
	moduleItemNode()
}

// moduleItemNode() ensures that only the following types can be
// assigned to ModuleItem.
//
func (AsyncFunc) moduleItemNode()             {}
func (Block) moduleItemNode()                 {}
func (BreakStmt) moduleItemNode()             {}
func (Class) moduleItemNode()                 {}
func (ContinueStmt) moduleItemNode()          {}
func (DebuggerStmt) moduleItemNode()          {}
func (DoWhileStmt) moduleItemNode()           {}
func (EmptyStmt) moduleItemNode()             {}
func (ExportDecl) moduleItemNode()            {}
func (ExportDefault) moduleItemNode()         {}
func (ExprStmt) moduleItemNode()              {}
func (ForInStmt) moduleItemNode()             {}
func (ForInStmtWithVar) moduleItemNode()      {}
func (ForOfStmt) moduleItemNode()             {}
func (ForOfStmtWithVar) moduleItemNode()      {}
func (ForStmt) moduleItemNode()               {}
func (ForStmtWithVar) moduleItemNode()        {}
func (Func) moduleItemNode()                  {}
func (Generator) moduleItemNode()             {}
func (IfStmt) moduleItemNode()                {}
func (ImportDecl) moduleItemNode()            {}
func (LabelledStmt) moduleItemNode()          {}
func (LexicalDecl) moduleItemNode()           {}
func (ReturnStmt) moduleItemNode()            {}
func (SwitchStmt) moduleItemNode()            {}
func (SyntaxProblem) moduleItemNode()         {}
func (ThrowStmt) moduleItemNode()             {}
func (TryStmt) moduleItemNode()               {}
func (TsAmbientClass) moduleItemNode()        {}
func (TsAmbientEnum) moduleItemNode()         {}
func (TsAmbientExportDecl) moduleItemNode()   {}
func (TsAmbientFunc) moduleItemNode()         {}
func (TsAmbientGlobal) moduleItemNode()       {}
func (TsAmbientImportAlias) moduleItemNode()  {}
func (TsAmbientInterface) moduleItemNode()    {}
func (TsAmbientModule) moduleItemNode()       {}
func (TsAmbientNamespace) moduleItemNode()    {}
func (TsAmbientTypeAlias) moduleItemNode()    {}
func (TsAmbientVar) moduleItemNode()          {}
func (TsEnum) moduleItemNode()                {}
func (TsExportAssignment) moduleItemNode()    {}
func (TsImportAliasDecl) moduleItemNode()     {}
func (TsImportRequireDecl) moduleItemNode()   {}
func (TsInterface) moduleItemNode()           {}
func (TsNamespace) moduleItemNode()           {}
func (TsNamespaceExportDecl) moduleItemNode() {}
func (TypeAliasDecl) moduleItemNode()         {}
func (VarStmt) moduleItemNode()               {}
func (WhileStmt) moduleItemNode()             {}
func (WithStmt) moduleItemNode()              {}
func (NilNode) moduleItemNode()               {}

type NamedImport interface {
	JsNode
	namedImportNode()
}

// namedImportNode() ensures that only the following types can be
// assigned to NamedImport.
//
func (ImportSpec) namedImportNode()    {}
func (SyntaxProblem) namedImportNode() {}
func (NilNode) namedImportNode()       {}

type Parameter interface {
	JsNode
	parameterNode()
}

// parameterNode() ensures that only the following types can be
// assigned to Parameter.
//
func (DefaultParameter) parameterNode() {}
func (RestParameter) parameterNode()    {}
func (SyntaxProblem) parameterNode()    {}
func (TsThisParameter) parameterNode()  {}
func (NilNode) parameterNode()          {}

type PropertyDefinition interface {
	JsNode
	propertyDefinitionNode()
}

// propertyDefinitionNode() ensures that only the following types can be
// assigned to PropertyDefinition.
//
func (ObjectMethod) propertyDefinitionNode()      {}
func (Property) propertyDefinitionNode()          {}
func (ShorthandProperty) propertyDefinitionNode() {}
func (SpreadProperty) propertyDefinitionNode()    {}
func (SyntaxProblem) propertyDefinitionNode()     {}
func (NilNode) propertyDefinitionNode()           {}

type PropertyName interface {
	JsNode
	propertyNameNode()
}

// propertyNameNode() ensures that only the following types can be
// assigned to PropertyName.
//
func (ComputedPropertyName) propertyNameNode() {}
func (LiteralPropertyName) propertyNameNode()  {}
func (NilNode) propertyNameNode()              {}

type PropertyPattern interface {
	JsNode
	propertyPatternNode()
}

// propertyPatternNode() ensures that only the following types can be
// assigned to PropertyPattern.
//
func (PropertyBinding) propertyPatternNode()   {}
func (SingleNameBinding) propertyPatternNode() {}
func (SyntaxProblem) propertyPatternNode()     {}
func (NilNode) propertyPatternNode()           {}

type Stmt interface {
	JsNode
	stmtNode()
}

// stmtNode() ensures that only the following types can be
// assigned to Stmt.
//
func (Block) stmtNode()            {}
func (BreakStmt) stmtNode()        {}
func (ContinueStmt) stmtNode()     {}
func (DebuggerStmt) stmtNode()     {}
func (DoWhileStmt) stmtNode()      {}
func (EmptyStmt) stmtNode()        {}
func (ExprStmt) stmtNode()         {}
func (ForInStmt) stmtNode()        {}
func (ForInStmtWithVar) stmtNode() {}
func (ForOfStmt) stmtNode()        {}
func (ForOfStmtWithVar) stmtNode() {}
func (ForStmt) stmtNode()          {}
func (ForStmtWithVar) stmtNode()   {}
func (IfStmt) stmtNode()           {}
func (LabelledStmt) stmtNode()     {}
func (ReturnStmt) stmtNode()       {}
func (SwitchStmt) stmtNode()       {}
func (ThrowStmt) stmtNode()        {}
func (TryStmt) stmtNode()          {}
func (VarStmt) stmtNode()          {}
func (WhileStmt) stmtNode()        {}
func (WithStmt) stmtNode()         {}
func (NilNode) stmtNode()          {}

type StmtListItem interface {
	JsNode
	stmtListItemNode()
}

// stmtListItemNode() ensures that only the following types can be
// assigned to StmtListItem.
//
func (AsyncFunc) stmtListItemNode()            {}
func (Block) stmtListItemNode()                {}
func (BreakStmt) stmtListItemNode()            {}
func (Class) stmtListItemNode()                {}
func (ContinueStmt) stmtListItemNode()         {}
func (DebuggerStmt) stmtListItemNode()         {}
func (DoWhileStmt) stmtListItemNode()          {}
func (EmptyStmt) stmtListItemNode()            {}
func (ExprStmt) stmtListItemNode()             {}
func (ForInStmt) stmtListItemNode()            {}
func (ForInStmtWithVar) stmtListItemNode()     {}
func (ForOfStmt) stmtListItemNode()            {}
func (ForOfStmtWithVar) stmtListItemNode()     {}
func (ForStmt) stmtListItemNode()              {}
func (ForStmtWithVar) stmtListItemNode()       {}
func (Func) stmtListItemNode()                 {}
func (Generator) stmtListItemNode()            {}
func (IfStmt) stmtListItemNode()               {}
func (LabelledStmt) stmtListItemNode()         {}
func (LexicalDecl) stmtListItemNode()          {}
func (ReturnStmt) stmtListItemNode()           {}
func (SwitchStmt) stmtListItemNode()           {}
func (SyntaxProblem) stmtListItemNode()        {}
func (ThrowStmt) stmtListItemNode()            {}
func (TryStmt) stmtListItemNode()              {}
func (TsAmbientClass) stmtListItemNode()       {}
func (TsAmbientEnum) stmtListItemNode()        {}
func (TsAmbientExportDecl) stmtListItemNode()  {}
func (TsAmbientFunc) stmtListItemNode()        {}
func (TsAmbientGlobal) stmtListItemNode()      {}
func (TsAmbientImportAlias) stmtListItemNode() {}
func (TsAmbientInterface) stmtListItemNode()   {}
func (TsAmbientModule) stmtListItemNode()      {}
func (TsAmbientNamespace) stmtListItemNode()   {}
func (TsAmbientTypeAlias) stmtListItemNode()   {}
func (TsAmbientVar) stmtListItemNode()         {}
func (TsEnum) stmtListItemNode()               {}
func (TsImportAliasDecl) stmtListItemNode()    {}
func (TsInterface) stmtListItemNode()          {}
func (TsNamespace) stmtListItemNode()          {}
func (TypeAliasDecl) stmtListItemNode()        {}
func (VarStmt) stmtListItemNode()              {}
func (WhileStmt) stmtListItemNode()            {}
func (WithStmt) stmtListItemNode()             {}
func (NilNode) stmtListItemNode()              {}

type TsAmbientElement interface {
	JsNode
	tsAmbientElementNode()
}

// tsAmbientElementNode() ensures that only the following types can be
// assigned to TsAmbientElement.
//
func (TsAmbientClass) tsAmbientElementNode()       {}
func (TsAmbientEnum) tsAmbientElementNode()        {}
func (TsAmbientExportDecl) tsAmbientElementNode()  {}
func (TsAmbientFunc) tsAmbientElementNode()        {}
func (TsAmbientGlobal) tsAmbientElementNode()      {}
func (TsAmbientImportAlias) tsAmbientElementNode() {}
func (TsAmbientInterface) tsAmbientElementNode()   {}
func (TsAmbientModule) tsAmbientElementNode()      {}
func (TsAmbientNamespace) tsAmbientElementNode()   {}
func (TsAmbientTypeAlias) tsAmbientElementNode()   {}
func (TsAmbientVar) tsAmbientElementNode()         {}
func (NilNode) tsAmbientElementNode()              {}

type TsType interface {
	JsNode
	tsTypeNode()
}

// tsTypeNode() ensures that only the following types can be
// assigned to TsType.
//
func (ArrayType) tsTypeNode()         {}
func (AssertsType) tsTypeNode()       {}
func (ConstructorType) tsTypeNode()   {}
func (FuncType) tsTypeNode()          {}
func (ImportType) tsTypeNode()        {}
func (IndexedAccessType) tsTypeNode() {}
func (IntersectionType) tsTypeNode()  {}
func (KeyOfType) tsTypeNode()         {}
func (LiteralType) tsTypeNode()       {}
func (MappedType) tsTypeNode()        {}
func (NonNullableType) tsTypeNode()   {}
func (NullableType) tsTypeNode()      {}
func (ObjectType) tsTypeNode()        {}
func (ParenthesizedType) tsTypeNode() {}
func (PredefinedType) tsTypeNode()    {}
func (ReadonlyType) tsTypeNode()      {}
func (RestType) tsTypeNode()          {}
func (ThisType) tsTypeNode()          {}
func (TsConditional) tsTypeNode()     {}
func (TupleType) tsTypeNode()         {}
func (TypePredicate) tsTypeNode()     {}
func (TypeQuery) tsTypeNode()         {}
func (TypeReference) tsTypeNode()     {}
func (TypeVar) tsTypeNode()           {}
func (UnionType) tsTypeNode()         {}
func (UniqueType) tsTypeNode()        {}
func (NilNode) tsTypeNode()           {}

type TypeMember interface {
	JsNode
	typeMemberNode()
}

// typeMemberNode() ensures that only the following types can be
// assigned to TypeMember.
//
func (CallSignature) typeMemberNode()      {}
func (ConstructSignature) typeMemberNode() {}
func (IndexSignature) typeMemberNode()     {}
func (MethodSignature) typeMemberNode()    {}
func (PropertySignature) typeMemberNode()  {}
func (NilNode) typeMemberNode()            {}

// Types.

type Abstract struct {
	*Node
}

type AccessibilityModifier struct {
	*Node
}

type AdditiveExpr struct {
	*Node
}

func (n AdditiveExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n AdditiveExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type Arguments struct {
	*Node
}

func (n Arguments) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

func (n Arguments) List() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expr))
	}
	return ret
}

type ArrayLiteral struct {
	*Node
}

func (n ArrayLiteral) List() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expr))
	}
	return ret
}

type ArrayPattern struct {
	*Node
}

func (n ArrayPattern) List() []JsNode {
	nodes := n.Children(selector.OneOf(js.AdditiveExpr, js.ArrayLiteral, js.ArrowFunc, js.AssignmentExpr, js.AsyncArrowFunc, js.AsyncFuncExpr, js.AwaitExpr, js.BitwiseAND, js.BitwiseOR, js.BitwiseXOR, js.CallExpr, js.ClassExpr, js.CoalesceExpr, js.CommaExpr, js.ConditionalExpr, js.ElementBinding, js.EqualityExpr, js.ExponentiationExpr, js.FuncExpr, js.GeneratorExpr, js.IdentExpr, js.InExpr, js.IndexAccess, js.InstanceOfExpr, js.JSXElement, js.Literal, js.LogicalAND, js.LogicalOR, js.MultiplicativeExpr, js.NewExpr, js.NewTarget, js.NoElement, js.ObjectLiteral, js.OptionalCallExpr, js.OptionalIndexAccess, js.OptionalPropertyAccess, js.OptionalTaggedTemplate, js.Parenthesized, js.PostDec, js.PostInc, js.PreDec, js.PreInc, js.PropertyAccess, js.Regexp, js.RelationalExpr, js.ShiftExpr, js.SingleNameBinding, js.SpreadElement, js.SuperExpr, js.SyntaxProblem, js.TaggedTemplate, js.TemplateLiteral, js.This, js.TsAsConstExpr, js.TsAsExpr, js.TsCastExpr, js.TsDynamicImport, js.TsNonNull, js.UnaryExpr, js.Yield))
	var ret = make([]JsNode, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JsNode))
	}
	return ret
}

func (n ArrayPattern) BindingRestElement() (BindingRestElement, bool) {
	field := BindingRestElement{n.Child(selector.BindingRestElement)}
	return field, field.IsValid()
}

type ArrayType struct {
	*Node
}

func (n ArrayType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ArrowFunc struct {
	*Node
}

func (n ArrowFunc) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n ArrowFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ArrowFunc) Parameters() (Parameters, bool) {
	field := Parameters{n.Child(selector.Parameters)}
	return field, field.IsValid()
}

func (n ArrowFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n ArrowFunc) Body() (Body, bool) {
	field := Body{n.Child(selector.Body)}
	return field, field.IsValid()
}

func (n ArrowFunc) ConciseBody() (ConciseBody, bool) {
	field := ConciseBody{n.Child(selector.ConciseBody)}
	return field, field.IsValid()
}

type AssertsType struct {
	*Node
}

func (n AssertsType) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

func (n AssertsType) TsType() (TsType, bool) {
	field := ToJsNode(n.Child(selector.TsType)).(TsType)
	return field, field.JsNode() != nil
}

type AssignmentExpr struct {
	*Node
}

func (n AssignmentExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n AssignmentExpr) AssignmentOperator() (AssignmentOperator, bool) {
	field := AssignmentOperator{n.Child(selector.AssignmentOperator)}
	return field, field.IsValid()
}

func (n AssignmentExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type AssignmentOperator struct {
	*Node
}

type AsyncArrowFunc struct {
	*Node
}

func (n AsyncArrowFunc) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n AsyncArrowFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncArrowFunc) Parameters() (Parameters, bool) {
	field := Parameters{n.Child(selector.Parameters)}
	return field, field.IsValid()
}

func (n AsyncArrowFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncArrowFunc) Body() (Body, bool) {
	field := Body{n.Child(selector.Body)}
	return field, field.IsValid()
}

func (n AsyncArrowFunc) ConciseBody() (ConciseBody, bool) {
	field := ConciseBody{n.Child(selector.ConciseBody)}
	return field, field.IsValid()
}

type AsyncFunc struct {
	*Node
}

func (n AsyncFunc) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n AsyncFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncFunc) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncFunc) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncFuncExpr struct {
	*Node
}

func (n AsyncFuncExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n AsyncFuncExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncFuncExpr) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFuncExpr) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncFuncExpr) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncMethod struct {
	*Node
}

func (n AsyncMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n AsyncMethod) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n AsyncMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncMethod) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n AsyncMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AwaitExpr struct {
	*Node
}

func (n AwaitExpr) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type BindingRestElement struct {
	*Node
}

func (n BindingRestElement) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type BitwiseAND struct {
	*Node
}

func (n BitwiseAND) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n BitwiseAND) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type BitwiseOR struct {
	*Node
}

func (n BitwiseOR) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n BitwiseOR) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type BitwiseXOR struct {
	*Node
}

func (n BitwiseXOR) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n BitwiseXOR) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type Block struct {
	*Node
}

func (n Block) CaseClause() []CaseClause {
	nodes := n.Children(selector.CaseClause)
	var ret = make([]CaseClause, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(CaseClause))
	}
	return ret
}

func (n Block) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type Body struct {
	*Node
}

func (n Body) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type BreakStmt struct {
	*Node
}

func (n BreakStmt) LabelIdent() (LabelIdent, bool) {
	field := LabelIdent{n.Child(selector.LabelIdent)}
	return field, field.IsValid()
}

type CallExpr struct {
	*Node
}

func (n CallExpr) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n CallExpr) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type CallSignature struct {
	*Node
}

func (n CallSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n CallSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n CallSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type Case struct {
	*Node
}

func (n Case) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n Case) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type Catch struct {
	*Node
}

func (n Catch) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n Catch) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n Catch) Block() Block {
	return Block{n.Child(selector.Block)}
}

type Class struct {
	*Node
}

func (n Class) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Class) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n Class) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Class) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()
}

func (n Class) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()
}

func (n Class) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type ClassBody struct {
	*Node
}

func (n ClassBody) ClassElement() []ClassElement {
	nodes := n.Children(selector.ClassElement)
	var ret = make([]ClassElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ClassElement))
	}
	return ret
}

type ClassExpr struct {
	*Node
}

func (n ClassExpr) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ClassExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n ClassExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ClassExpr) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()
}

func (n ClassExpr) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()
}

func (n ClassExpr) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type CoalesceExpr struct {
	*Node
}

func (n CoalesceExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n CoalesceExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type CommaExpr struct {
	*Node
}

func (n CommaExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n CommaExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ComputedPropertyName struct {
	*Node
}

func (n ComputedPropertyName) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type ConciseBody struct {
	*Node
}

func (n ConciseBody) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type ConditionalExpr struct {
	*Node
}

func (n ConditionalExpr) Cond() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ConditionalExpr) Then() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

func (n ConditionalExpr) Else() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr).Next(selector.Expr)).(Expr)
}

type ConstructSignature struct {
	*Node
}

func (n ConstructSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ConstructSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ConstructSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type ConstructorType struct {
	*Node
}

func (n ConstructorType) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n ConstructorType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructorType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ContinueStmt struct {
	*Node
}

func (n ContinueStmt) LabelIdent() (LabelIdent, bool) {
	field := LabelIdent{n.Child(selector.LabelIdent)}
	return field, field.IsValid()
}

type DebuggerStmt struct {
	*Node
}

type Declare struct {
	*Node
}

type DecoratorCall struct {
	*Node
}

func (n DecoratorCall) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

func (n DecoratorCall) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type DecoratorExpr struct {
	*Node
}

func (n DecoratorExpr) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type Default struct {
	*Node
}

func (n Default) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type DefaultParameter struct {
	*Node
}

func (n DefaultParameter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n DefaultParameter) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n DefaultParameter) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n DefaultParameter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n DefaultParameter) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type DoWhileStmt struct {
	*Node
}

func (n DoWhileStmt) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

func (n DoWhileStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type ElementBinding struct {
	*Node
}

func (n ElementBinding) BindingPattern() BindingPattern {
	return ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
}

func (n ElementBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type EmptyDecl struct {
	*Node
}

type EmptyStmt struct {
	*Node
}

type EqualityExpr struct {
	*Node
}

func (n EqualityExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n EqualityExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ExponentiationExpr struct {
	*Node
}

func (n ExponentiationExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ExponentiationExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ExportClause struct {
	*Node
}

func (n ExportClause) ExportElement() []ExportElement {
	nodes := n.Children(selector.ExportElement)
	var ret = make([]ExportElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ExportElement))
	}
	return ret
}

type ExportDecl struct {
	*Node
}

func (n ExportDecl) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDecl) TsTypeOnly() (TsTypeOnly, bool) {
	field := TsTypeOnly{n.Child(selector.TsTypeOnly)}
	return field, field.IsValid()
}

func (n ExportDecl) VarStmt() (VarStmt, bool) {
	field := VarStmt{n.Child(selector.VarStmt)}
	return field, field.IsValid()
}

func (n ExportDecl) Decl() (Decl, bool) {
	field := ToJsNode(n.Child(selector.Decl)).(Decl)
	return field, field.JsNode() != nil
}

func (n ExportDecl) ExportClause() (ExportClause, bool) {
	field := ExportClause{n.Child(selector.ExportClause)}
	return field, field.IsValid()
}

func (n ExportDecl) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n ExportDecl) ModuleSpec() (ModuleSpec, bool) {
	field := ModuleSpec{n.Child(selector.ModuleSpec)}
	return field, field.IsValid()
}

type ExportDefault struct {
	*Node
}

func (n ExportDefault) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

func (n ExportDefault) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDefault) Decl() (Decl, bool) {
	field := ToJsNode(n.Child(selector.Decl)).(Decl)
	return field, field.JsNode() != nil
}

type ExportSpec struct {
	*Node
}

func (n ExportSpec) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

func (n ExportSpec) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

type ExprStmt struct {
	*Node
}

func (n ExprStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type Extends struct {
	*Node
}

func (n Extends) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

func (n Extends) TypeReference() (TypeReference, bool) {
	field := TypeReference{n.Child(selector.TypeReference)}
	return field, field.IsValid()
}

type Finally struct {
	*Node
}

func (n Finally) Block() Block {
	return Block{n.Child(selector.Block)}
}

type ForBinding struct {
	*Node
}

func (n ForBinding) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n ForBinding) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

type ForCondition struct {
	*Node
}

func (n ForCondition) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type ForFinalExpr struct {
	*Node
}

func (n ForFinalExpr) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type ForInStmt struct {
	*Node
}

func (n ForInStmt) Var() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForInStmt) Object() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

func (n ForInStmt) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForInStmtWithVar struct {
	*Node
}

func (n ForInStmtWithVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()
}

func (n ForInStmtWithVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()
}

func (n ForInStmtWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForInStmtWithVar) Object() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForInStmtWithVar) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForOfStmt struct {
	*Node
}

func (n ForOfStmt) Var() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForOfStmt) Iterable() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

func (n ForOfStmt) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForOfStmtWithVar struct {
	*Node
}

func (n ForOfStmtWithVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()
}

func (n ForOfStmtWithVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()
}

func (n ForOfStmtWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForOfStmtWithVar) Iterable() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ForOfStmtWithVar) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForStmt struct {
	*Node
}

func (n ForStmt) Var() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

func (n ForStmt) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStmt) ForFinalExpr() ForFinalExpr {
	return ForFinalExpr{n.Child(selector.ForFinalExpr)}
}

func (n ForStmt) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type ForStmtWithVar struct {
	*Node
}

func (n ForStmtWithVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()
}

func (n ForStmtWithVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()
}

func (n ForStmtWithVar) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

func (n ForStmtWithVar) VarDecl() []VarDecl {
	nodes := n.Children(selector.VarDecl)
	var ret = make([]VarDecl, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VarDecl{node})
	}
	return ret
}

func (n ForStmtWithVar) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStmtWithVar) ForFinalExpr() ForFinalExpr {
	return ForFinalExpr{n.Child(selector.ForFinalExpr)}
}

func (n ForStmtWithVar) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type Func struct {
	*Node
}

func (n Func) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n Func) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Func) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Func) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Func) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FuncExpr struct {
	*Node
}

func (n FuncExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n FuncExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n FuncExpr) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FuncExpr) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n FuncExpr) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FuncType struct {
	*Node
}

func (n FuncType) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n FuncType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FuncType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type Generator struct {
	*Node
}

func (n Generator) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n Generator) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Generator) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Generator) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Generator) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorExpr struct {
	*Node
}

func (n GeneratorExpr) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n GeneratorExpr) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n GeneratorExpr) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorExpr) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n GeneratorExpr) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorMethod struct {
	*Node
}

func (n GeneratorMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n GeneratorMethod) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n GeneratorMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorMethod) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n GeneratorMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Getter struct {
	*Node
}

func (n Getter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Getter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Getter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type IdentExpr struct {
	*Node
}

func (n IdentExpr) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type IfStmt struct {
	*Node
}

func (n IfStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n IfStmt) Then() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

func (n IfStmt) Else() (Stmt, bool) {
	field := ToJsNode(n.Child(selector.Stmt).Next(selector.Stmt)).(Stmt)
	return field, field.JsNode() != nil
}

type ImportDecl struct {
	*Node
}

func (n ImportDecl) TsTypeOnly() (TsTypeOnly, bool) {
	field := TsTypeOnly{n.Child(selector.TsTypeOnly)}
	return field, field.IsValid()
}

func (n ImportDecl) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n ImportDecl) NameSpaceImport() (NameSpaceImport, bool) {
	field := NameSpaceImport{n.Child(selector.NameSpaceImport)}
	return field, field.IsValid()
}

func (n ImportDecl) NamedImports() (NamedImports, bool) {
	field := NamedImports{n.Child(selector.NamedImports)}
	return field, field.IsValid()
}

func (n ImportDecl) ModuleSpec() ModuleSpec {
	return ModuleSpec{n.Child(selector.ModuleSpec)}
}

type ImportSpec struct {
	*Node
}

func (n ImportSpec) ReferenceIdent() (ReferenceIdent, bool) {
	field := ReferenceIdent{n.Child(selector.ReferenceIdent)}
	return field, field.IsValid()
}

func (n ImportSpec) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type ImportType struct {
	*Node
}

func (n ImportType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n ImportType) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

func (n ImportType) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

type InExpr struct {
	*Node
}

func (n InExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n InExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type IndexAccess struct {
	*Node
}

func (n IndexAccess) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n IndexAccess) Index() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type IndexSignature struct {
	*Node
}

func (n IndexSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n IndexSignature) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n IndexSignature) PredefinedType() PredefinedType {
	return PredefinedType{n.Child(selector.PredefinedType)}
}

func (n IndexSignature) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type IndexedAccessType struct {
	*Node
}

func (n IndexedAccessType) Left() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n IndexedAccessType) Index() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

type Initializer struct {
	*Node
}

func (n Initializer) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type InstanceOfExpr struct {
	*Node
}

func (n InstanceOfExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n InstanceOfExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type IntersectionType struct {
	*Node
}

func (n IntersectionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type JSXAttributeName struct {
	*Node
}

type JSXClosingElement struct {
	*Node
}

func (n JSXClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

type JSXElement struct {
	*Node
}

func (n JSXElement) JSXOpeningElement() (JSXOpeningElement, bool) {
	field := JSXOpeningElement{n.Child(selector.JSXOpeningElement)}
	return field, field.IsValid()
}

func (n JSXElement) JSXSelfClosingElement() (JSXSelfClosingElement, bool) {
	field := JSXSelfClosingElement{n.Child(selector.JSXSelfClosingElement)}
	return field, field.IsValid()
}

func (n JSXElement) JSXChild() []JSXChild {
	nodes := n.Children(selector.JSXChild)
	var ret = make([]JSXChild, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXChild))
	}
	return ret
}

func (n JSXElement) JSXClosingElement() (JSXClosingElement, bool) {
	field := JSXClosingElement{n.Child(selector.JSXClosingElement)}
	return field, field.IsValid()
}

type JSXElementName struct {
	*Node
}

type JSXExpr struct {
	*Node
}

func (n JSXExpr) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type JSXLiteral struct {
	*Node
}

type JSXNormalAttribute struct {
	*Node
}

func (n JSXNormalAttribute) JSXAttributeName() JSXAttributeName {
	return JSXAttributeName{n.Child(selector.JSXAttributeName)}
}

func (n JSXNormalAttribute) JSXAttributeValue() (JSXAttributeValue, bool) {
	field := ToJsNode(n.Child(selector.JSXAttributeValue)).(JSXAttributeValue)
	return field, field.JsNode() != nil
}

type JSXOpeningElement struct {
	*Node
}

func (n JSXOpeningElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXOpeningElement) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

func (n JSXOpeningElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var ret = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXAttribute))
	}
	return ret
}

type JSXSelfClosingElement struct {
	*Node
}

func (n JSXSelfClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXSelfClosingElement) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

func (n JSXSelfClosingElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var ret = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXAttribute))
	}
	return ret
}

type JSXSpreadAttribute struct {
	*Node
}

func (n JSXSpreadAttribute) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type JSXSpreadExpr struct {
	*Node
}

func (n JSXSpreadExpr) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type JSXText struct {
	*Node
}

type KeyOfType struct {
	*Node
}

func (n KeyOfType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type LabelIdent struct {
	*Node
}

type LabelledStmt struct {
	*Node
}

func (n LabelledStmt) LabelIdent() LabelIdent {
	return LabelIdent{n.Child(selector.LabelIdent)}
}

func (n LabelledStmt) Func() (Func, bool) {
	field := Func{n.Child(selector.Func)}
	return field, field.IsValid()
}

func (n LabelledStmt) Stmt() (Stmt, bool) {
	field := ToJsNode(n.Child(selector.Stmt)).(Stmt)
	return field, field.JsNode() != nil
}

type LetOrConst struct {
	*Node
}

type LexicalBinding struct {
	*Node
}

func (n LexicalBinding) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n LexicalBinding) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n LexicalBinding) TsExclToken() (TsExclToken, bool) {
	field := TsExclToken{n.Child(selector.TsExclToken)}
	return field, field.IsValid()
}

func (n LexicalBinding) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n LexicalBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type LexicalDecl struct {
	*Node
}

func (n LexicalDecl) LetOrConst() LetOrConst {
	return LetOrConst{n.Child(selector.LetOrConst)}
}

func (n LexicalDecl) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

type Literal struct {
	*Node
}

type LiteralPropertyName struct {
	*Node
}

func (n LiteralPropertyName) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

type LiteralType struct {
	*Node
}

type LogicalAND struct {
	*Node
}

func (n LogicalAND) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n LogicalAND) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type LogicalOR struct {
	*Node
}

func (n LogicalOR) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n LogicalOR) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type MappedType struct {
	*Node
}

func (n MappedType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n MappedType) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type MemberMethod struct {
	*Node
}

func (n MemberMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MemberMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type MemberVar struct {
	*Node
}

func (n MemberVar) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MemberVar) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MemberVar) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n MemberVar) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type Method struct {
	*Node
}

func (n Method) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Method) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n Method) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Method) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n Method) Body() Body {
	return Body{n.Child(selector.Body)}
}

type MethodSignature struct {
	*Node
}

func (n MethodSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MethodSignature) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MethodSignature) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n MethodSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n MethodSignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type Module struct {
	*Node
}

func (n Module) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type ModuleSpec struct {
	*Node
}

type MultiplicativeExpr struct {
	*Node
}

func (n MultiplicativeExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n MultiplicativeExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type NameIdent struct {
	*Node
}

type NameSpaceImport struct {
	*Node
}

func (n NameSpaceImport) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type NamedImports struct {
	*Node
}

func (n NamedImports) NamedImport() []NamedImport {
	nodes := n.Children(selector.NamedImport)
	var ret = make([]NamedImport, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(NamedImport))
	}
	return ret
}

type NewExpr struct {
	*Node
}

func (n NewExpr) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n NewExpr) Arguments() (Arguments, bool) {
	field := Arguments{n.Child(selector.Arguments)}
	return field, field.IsValid()
}

type NewTarget struct {
	*Node
}

type NoElement struct {
	*Node
}

type NonNullableType struct {
	*Node
}

func (n NonNullableType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type NullableType struct {
	*Node
}

func (n NullableType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ObjectLiteral struct {
	*Node
}

func (n ObjectLiteral) PropertyDefinition() []PropertyDefinition {
	nodes := n.Children(selector.PropertyDefinition)
	var ret = make([]PropertyDefinition, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(PropertyDefinition))
	}
	return ret
}

type ObjectMethod struct {
	*Node
}

func (n ObjectMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ObjectMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type ObjectPattern struct {
	*Node
}

func (n ObjectPattern) PropertyPattern() []PropertyPattern {
	nodes := n.Children(selector.PropertyPattern)
	var ret = make([]PropertyPattern, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(PropertyPattern))
	}
	return ret
}

func (n ObjectPattern) BindingRestElement() (BindingRestElement, bool) {
	field := BindingRestElement{n.Child(selector.BindingRestElement)}
	return field, field.IsValid()
}

type ObjectType struct {
	*Node
}

func (n ObjectType) TypeMember() []TypeMember {
	nodes := n.Children(selector.TypeMember)
	var ret = make([]TypeMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TypeMember))
	}
	return ret
}

type OptionalCallExpr struct {
	*Node
}

func (n OptionalCallExpr) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalCallExpr) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type OptionalIndexAccess struct {
	*Node
}

func (n OptionalIndexAccess) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalIndexAccess) Index() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type OptionalPropertyAccess struct {
	*Node
}

func (n OptionalPropertyAccess) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalPropertyAccess) Selector() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type OptionalTaggedTemplate struct {
	*Node
}

func (n OptionalTaggedTemplate) Tag() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n OptionalTaggedTemplate) Literal() TemplateLiteral {
	return TemplateLiteral{n.Child(selector.Expr).Next(selector.TemplateLiteral)}
}

type Parameters struct {
	*Node
}

func (n Parameters) Parameter() []Parameter {
	nodes := n.Children(selector.Parameter)
	var ret = make([]Parameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Parameter))
	}
	return ret
}

type Parenthesized struct {
	*Node
}

func (n Parenthesized) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

func (n Parenthesized) SyntaxProblem() (SyntaxProblem, bool) {
	field := SyntaxProblem{n.Child(selector.SyntaxProblem)}
	return field, field.IsValid()
}

type ParenthesizedType struct {
	*Node
}

func (n ParenthesizedType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type PostDec struct {
	*Node
}

func (n PostDec) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type PostInc struct {
	*Node
}

func (n PostInc) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type PreDec struct {
	*Node
}

func (n PreDec) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type PreInc struct {
	*Node
}

func (n PreInc) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type PredefinedType struct {
	*Node
}

type Property struct {
	*Node
}

func (n Property) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Property) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Property) Value() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type PropertyAccess struct {
	*Node
}

func (n PropertyAccess) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n PropertyAccess) Selector() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type PropertyBinding struct {
	*Node
}

func (n PropertyBinding) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertyBinding) ElementPattern() ElementPattern {
	return ToJsNode(n.Child(selector.ElementPattern)).(ElementPattern)
}

type PropertySignature struct {
	*Node
}

func (n PropertySignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n PropertySignature) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertySignature) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type Readonly struct {
	*Node
}

type ReadonlyType struct {
	*Node
}

func (n ReadonlyType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ReferenceIdent struct {
	*Node
}

type Regexp struct {
	*Node
}

type RelationalExpr struct {
	*Node
}

func (n RelationalExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n RelationalExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type RestParameter struct {
	*Node
}

func (n RestParameter) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n RestParameter) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type RestType struct {
	*Node
}

func (n RestType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ReturnStmt struct {
	*Node
}

func (n ReturnStmt) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type Setter struct {
	*Node
}

func (n Setter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Setter) Parameter() Parameter {
	return ToJsNode(n.Child(selector.Parameter)).(Parameter)
}

func (n Setter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type ShiftExpr struct {
	*Node
}

func (n ShiftExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n ShiftExpr) Right() Expr {
	return ToJsNode(n.Child(selector.Expr).Next(selector.Expr)).(Expr)
}

type ShorthandProperty struct {
	*Node
}

func (n ShorthandProperty) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type SingleNameBinding struct {
	*Node
}

func (n SingleNameBinding) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n SingleNameBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type SpreadElement struct {
	*Node
}

func (n SpreadElement) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type SpreadProperty struct {
	*Node
}

func (n SpreadProperty) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type Static struct {
	*Node
}

type SuperExpr struct {
	*Node
}

type SwitchStmt struct {
	*Node
}

func (n SwitchStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n SwitchStmt) Block() Block {
	return Block{n.Child(selector.Block)}
}

type SyntaxProblem struct {
	*Node
}

func (n SyntaxProblem) ReferenceIdent() (ReferenceIdent, bool) {
	field := ReferenceIdent{n.Child(selector.ReferenceIdent)}
	return field, field.IsValid()
}

func (n SyntaxProblem) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type TaggedTemplate struct {
	*Node
}

func (n TaggedTemplate) Tag() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n TaggedTemplate) Literal() TemplateLiteral {
	return TemplateLiteral{n.Child(selector.Expr).Next(selector.TemplateLiteral)}
}

type TemplateLiteral struct {
	*Node
}

func (n TemplateLiteral) Template() []Token {
	nodes := n.Children(selector.OneOf(js.NoSubstitutionTemplate, js.TemplateHead, js.TemplateMiddle, js.TemplateTail))
	var ret = make([]Token, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Token))
	}
	return ret
}

func (n TemplateLiteral) Substitution() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expr))
	}
	return ret
}

type This struct {
	*Node
}

type ThisType struct {
	*Node
}

type ThrowStmt struct {
	*Node
}

func (n ThrowStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type TryStmt struct {
	*Node
}

func (n TryStmt) Block() Block {
	return Block{n.Child(selector.Block)}
}

func (n TryStmt) Catch() (Catch, bool) {
	field := Catch{n.Child(selector.Catch)}
	return field, field.IsValid()
}

func (n TryStmt) Finally() (Finally, bool) {
	field := Finally{n.Child(selector.Finally)}
	return field, field.IsValid()
}

type TsAmbientBinding struct {
	*Node
}

func (n TsAmbientBinding) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientBinding) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n TsAmbientBinding) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type TsAmbientClass struct {
	*Node
}

func (n TsAmbientClass) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientClass) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientClass) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientClass) Extends() (Extends, bool) {
	field := Extends{n.Child(selector.Extends)}
	return field, field.IsValid()
}

func (n TsAmbientClass) TsImplementsClause() (TsImplementsClause, bool) {
	field := TsImplementsClause{n.Child(selector.TsImplementsClause)}
	return field, field.IsValid()
}

func (n TsAmbientClass) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type TsAmbientEnum struct {
	*Node
}

func (n TsAmbientEnum) TsConst() (TsConst, bool) {
	field := TsConst{n.Child(selector.TsConst)}
	return field, field.IsValid()
}

func (n TsAmbientEnum) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientEnum) TsEnumBody() TsEnumBody {
	return TsEnumBody{n.Child(selector.TsEnumBody)}
}

type TsAmbientExportDecl struct {
	*Node
}

func (n TsAmbientExportDecl) ExportClause() ExportClause {
	return ExportClause{n.Child(selector.ExportClause)}
}

type TsAmbientFunc struct {
	*Node
}

func (n TsAmbientFunc) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientFunc) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientFunc) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n TsAmbientFunc) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

type TsAmbientGlobal struct {
	*Node
}

func (n TsAmbientGlobal) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsAmbientImportAlias struct {
	*Node
}

func (n TsAmbientImportAlias) TsImportAliasDecl() TsImportAliasDecl {
	return TsImportAliasDecl{n.Child(selector.TsImportAliasDecl)}
}

type TsAmbientInterface struct {
	*Node
}

func (n TsAmbientInterface) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientInterface) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsAmbientInterface) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsAmbientInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	field := TsInterfaceExtends{n.Child(selector.TsInterfaceExtends)}
	return field, field.IsValid()
}

func (n TsAmbientInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsAmbientModule struct {
	*Node
}

func (n TsAmbientModule) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsAmbientModule) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsAmbientNamespace struct {
	*Node
}

func (n TsAmbientNamespace) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsAmbientNamespace) TsAmbientElement() []TsAmbientElement {
	nodes := n.Children(selector.TsAmbientElement)
	var ret = make([]TsAmbientElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsAmbientElement))
	}
	return ret
}

type TsAmbientTypeAlias struct {
	*Node
}

func (n TsAmbientTypeAlias) TypeAliasDecl() TypeAliasDecl {
	return TypeAliasDecl{n.Child(selector.TypeAliasDecl)}
}

type TsAmbientVar struct {
	*Node
}

func (n TsAmbientVar) LetOrConst() (LetOrConst, bool) {
	field := LetOrConst{n.Child(selector.LetOrConst)}
	return field, field.IsValid()
}

func (n TsAmbientVar) Var() (Var, bool) {
	field := Var{n.Child(selector.Var)}
	return field, field.IsValid()
}

func (n TsAmbientVar) TsAmbientBinding() []TsAmbientBinding {
	nodes := n.Children(selector.TsAmbientBinding)
	var ret = make([]TsAmbientBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsAmbientBinding{node})
	}
	return ret
}

type TsAsConstExpr struct {
	*Node
}

func (n TsAsConstExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n TsAsConstExpr) TsConst() TsConst {
	return TsConst{n.Child(selector.TsConst)}
}

type TsAsExpr struct {
	*Node
}

func (n TsAsExpr) Left() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n TsAsExpr) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TsCastExpr struct {
	*Node
}

func (n TsCastExpr) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsCastExpr) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type TsConditional struct {
	*Node
}

func (n TsConditional) Check() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsConditional) Ext() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

func (n TsConditional) Truet() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType)).(TsType)
}

func (n TsConditional) Falset() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType).Next(selector.TsType)).(TsType)
}

type TsConst struct {
	*Node
}

type TsDynamicImport struct {
	*Node
}

func (n TsDynamicImport) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type TsEnum struct {
	*Node
}

func (n TsEnum) TsConst() (TsConst, bool) {
	field := TsConst{n.Child(selector.TsConst)}
	return field, field.IsValid()
}

func (n TsEnum) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsEnum) TsEnumBody() TsEnumBody {
	return TsEnumBody{n.Child(selector.TsEnumBody)}
}

type TsEnumBody struct {
	*Node
}

func (n TsEnumBody) TsEnumMember() []TsEnumMember {
	nodes := n.Children(selector.TsEnumMember)
	var ret = make([]TsEnumMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsEnumMember{node})
	}
	return ret
}

type TsEnumMember struct {
	*Node
}

func (n TsEnumMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsEnumMember) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type TsExclToken struct {
	*Node
}

type TsExport struct {
	*Node
}

type TsExportAssignment struct {
	*Node
}

func (n TsExportAssignment) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type TsImplementsClause struct {
	*Node
}

func (n TsImplementsClause) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var ret = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeReference{node})
	}
	return ret
}

type TsImportAliasDecl struct {
	*Node
}

func (n TsImportAliasDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsImportAliasDecl) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TsImportRequireDecl struct {
	*Node
}

func (n TsImportRequireDecl) TsExport() (TsExport, bool) {
	field := TsExport{n.Child(selector.TsExport)}
	return field, field.IsValid()
}

func (n TsImportRequireDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type TsIndexMemberDecl struct {
	*Node
}

func (n TsIndexMemberDecl) IndexSignature() IndexSignature {
	return IndexSignature{n.Child(selector.IndexSignature)}
}

type TsInterface struct {
	*Node
}

func (n TsInterface) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TsInterface) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TsInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	field := TsInterfaceExtends{n.Child(selector.TsInterfaceExtends)}
	return field, field.IsValid()
}

func (n TsInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsInterfaceExtends struct {
	*Node
}

func (n TsInterfaceExtends) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var ret = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeReference{node})
	}
	return ret
}

type TsNamespace struct {
	*Node
}

func (n TsNamespace) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsNamespace) TsNamespaceBody() TsNamespaceBody {
	return TsNamespaceBody{n.Child(selector.TsNamespaceBody)}
}

type TsNamespaceBody struct {
	*Node
}

func (n TsNamespaceBody) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsNamespaceExportDecl struct {
	*Node
}

func (n TsNamespaceExportDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

type TsNonNull struct {
	*Node
}

func (n TsNonNull) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type TsThisParameter struct {
	*Node
}

func (n TsThisParameter) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type TsTypeOnly struct {
	*Node
}

type TupleType struct {
	*Node
}

func (n TupleType) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TypeAliasDecl struct {
	*Node
}

func (n TypeAliasDecl) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TypeAliasDecl) TypeParameters() (TypeParameters, bool) {
	field := TypeParameters{n.Child(selector.TypeParameters)}
	return field, field.IsValid()
}

func (n TypeAliasDecl) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeAnnotation struct {
	*Node
}

func (n TypeAnnotation) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeArguments struct {
	*Node
}

func (n TypeArguments) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TypeConstraint struct {
	*Node
}

func (n TypeConstraint) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeName struct {
	*Node
}

func (n TypeName) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TypeParameter struct {
	*Node
}

func (n TypeParameter) NameIdent() NameIdent {
	return NameIdent{n.Child(selector.NameIdent)}
}

func (n TypeParameter) TypeConstraint() (TypeConstraint, bool) {
	field := TypeConstraint{n.Child(selector.TypeConstraint)}
	return field, field.IsValid()
}

func (n TypeParameter) TsType() (TsType, bool) {
	field := ToJsNode(n.Child(selector.TsType)).(TsType)
	return field, field.JsNode() != nil
}

type TypeParameters struct {
	*Node
}

func (n TypeParameters) TypeParameter() []TypeParameter {
	nodes := n.Children(selector.TypeParameter)
	var ret = make([]TypeParameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TypeParameter{node})
	}
	return ret
}

type TypePredicate struct {
	*Node
}

func (n TypePredicate) Paramref() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

func (n TypePredicate) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeQuery struct {
	*Node
}

func (n TypeQuery) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TypeReference struct {
	*Node
}

func (n TypeReference) TypeName() TypeName {
	return TypeName{n.Child(selector.TypeName)}
}

func (n TypeReference) TypeArguments() (TypeArguments, bool) {
	field := TypeArguments{n.Child(selector.TypeArguments)}
	return field, field.IsValid()
}

type TypeVar struct {
	*Node
}

func (n TypeVar) ReferenceIdent() ReferenceIdent {
	return ReferenceIdent{n.Child(selector.ReferenceIdent)}
}

type UnaryExpr struct {
	*Node
}

func (n UnaryExpr) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

type UnionType struct {
	*Node
}

func (n UnionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type UniqueType struct {
	*Node
}

func (n UniqueType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type Var struct {
	*Node
}

type VarDecl struct {
	*Node
}

func (n VarDecl) BindingPattern() (BindingPattern, bool) {
	field := ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
	return field, field.JsNode() != nil
}

func (n VarDecl) NameIdent() (NameIdent, bool) {
	field := NameIdent{n.Child(selector.NameIdent)}
	return field, field.IsValid()
}

func (n VarDecl) TsExclToken() (TsExclToken, bool) {
	field := TsExclToken{n.Child(selector.TsExclToken)}
	return field, field.IsValid()
}

func (n VarDecl) TypeAnnotation() (TypeAnnotation, bool) {
	field := TypeAnnotation{n.Child(selector.TypeAnnotation)}
	return field, field.IsValid()
}

func (n VarDecl) Initializer() (Initializer, bool) {
	field := Initializer{n.Child(selector.Initializer)}
	return field, field.IsValid()
}

type VarStmt struct {
	*Node
}

func (n VarStmt) VarDecl() []VarDecl {
	nodes := n.Children(selector.VarDecl)
	var ret = make([]VarDecl, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VarDecl{node})
	}
	return ret
}

type WhileStmt struct {
	*Node
}

func (n WhileStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n WhileStmt) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type WithStmt struct {
	*Node
}

func (n WithStmt) Expr() Expr {
	return ToJsNode(n.Child(selector.Expr)).(Expr)
}

func (n WithStmt) Stmt() Stmt {
	return ToJsNode(n.Child(selector.Stmt)).(Stmt)
}

type Yield struct {
	*Node
}

func (n Yield) Expr() (Expr, bool) {
	field := ToJsNode(n.Child(selector.Expr)).(Expr)
	return field, field.JsNode() != nil
}

type InsertedSemicolon struct {
	*Node
}
